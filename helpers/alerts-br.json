[
  {
    "description": "É possível visualizar a lista de diretórios. A listagem do diretório pode revelar scripts ocultos, incluir arquivos, arquivos de origem de backup, etc., que podem ser acessados para ler informações confidenciais.",
    "solution": "Desativar a navegação do diretório. Se isso for necessário, certifique-se de que os arquivos listados não induzem riscos.",
    "alert": "Navegação do diretório",
    "alertRef": "0"
  },
  {
    "description": "Um IP privado (como 10.x.x.x.x, 172.x.x.x, 192.168.x.x) ou um hostname privado do Amazon EC2 (por exemplo, ip-10-0-56-78) foi encontrado no corpo de resposta HTTP. Essas informações podem ser úteis para novos ataques direcionados a sistemas internos.",
    "solution": "Remova o endereço IP privado do corpo de resposta HTTP. Para comentários, use o comentário JSP/ASP/PHP em vez do comentário HTML/JavaScript que pode ser visto pelos navegadores do cliente.",
    "alert": "Divulgação IP privada",
    "alertRef": "2"
  },
  {
    "description": "A reescrita da URL é usada para rastrear o ID da sessão do usuário. O ID da sessão pode ser divulgado via cabeçalho de árbitro cruzado. Além disso, o ID de sessão pode ser armazenado no histórico do navegador ou nos logs do servidor.",
    "solution": "Para conteúdo seguro, coloque ID de sessão em um cookie. Para ser ainda mais seguro considere usar uma combinação de cookies e reescrita URL.",
    "alert": "ID de sessão em URL Rewrite",
    "alertRef": "3"
  },
  {
    "description": "A técnica de ataque Path Traversal permite que um acesso ao atacante a arquivos, diretórios e comandos que potencialmente residem fora do diretório raiz do documento web. Um atacante pode manipular uma URL de tal forma que o site irá executar ou revelar o conteúdo de arquivos arbitrários em qualquer lugar do servidor web. Qualquer dispositivo que exponha uma interface baseada em HTTP é potencialmente vulnerável ao Path Traversal.",
    "solution": "Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Para nomes de arquivos, use listas de permissões rigorosas que limitem o conjunto de caracteres a ser usado. Se possível, apenas permita que um único caractere '.' no nome do arquivo evite fraquezas e exclua separadores de diretórios como '/'. Use uma lista permitida de extensões de arquivo permitidas. Atenção: se você tentar limpar seus dados, então faça isso para que o resultado final não esteja na forma que possa ser perigosa. Um mecanismo de higienização pode remover caracteres como '.' e ';' que podem ser necessários para algumas explorações. Um atacante pode tentar enganar o mecanismo sanitizing na limpeza de dados em uma forma perigosa. Suponha que o atacante injeta um '.' dentro de um nome de arquivo (por exemplo, sensi.tiveFile) e o mecanismo de higienização remove o personagem resultando no nome de arquivo válido, sensívelFile. Se os dados de entrada são agora assumidos como seguros, então o arquivo pode ser comprometido. As entradas devem ser decodificadas e canonicalizadas para a representação interna atual da aplicação antes de serem validadas. Certifique-se de que sua aplicação não decodifica a mesma entrada duas vezes. Tais erros podem ser usados para ignorar permitir esquemas de lista introduzindo entradas perigosas após terem sido verificados. Use uma função de canonicalização de caminho incorporado (como realpath)( em C) que produz a versão canônica do nome do caminho, que efetivamente remove as sequências '.' e links simbólicos. Execute seu código usando os privilégios mais baixos que são necessários para realizar as tarefas necessárias. Se possível, crie contas isoladas com privilégios limitados que só são usados para uma única tarefa. Dessa forma, um ataque bem sucedido não dará imediatamente ao atacante acesso ao resto do software ou seu ambiente. Por exemplo, os aplicativos de banco de dados raramente precisam ser executados como o administrador do banco de dados, especialmente em operações diárias. Quando o conjunto de objetos aceitáveis, como nomes de arquivos ou URLs, é limitado ou conhecido, criar um mapeamento de um conjunto de valores de entrada fixos (como IDs numéricos) para os nomes de arquivos ou URLs reais, e rejeitar todas as outras entradas. Execute seu código em um ambiente de jail ou similar sandbox que impõe limites rigorosos entre o processo e o sistema operacional. Isso pode efetivamente restringir quais arquivos podem ser acessados em um determinado diretório ou quais comandos podem ser executados pelo seu software. Exemplos de nível de sistema operacional incluem a cadeia de chroot Unix, AppArmor e SELinux. Em geral, o código gerenciado pode fornecer alguma proteção. Por exemplo, java.io.FilePermission no Java Security O gerente permite especificar restrições nas operações de arquivos. Isso pode não ser uma solução viável, e limita apenas o impacto ao sistema operacional; o resto da sua aplicação ainda pode estar sujeito a compromisso.",
    "alert": "Traversal do Caminho",
    "alertRef": "6"
  },
  {
    "description": "O Remote File Inclui (RFI) é uma técnica de ataque usada para explorar mecanismos de “arquivo dinâmico” em aplicações web. Quando os aplicativos da web levam a entrada do usuário (URL, valor do parâmetro, etc.) e passá-los em arquivos incluem comandos, o aplicativo web pode ser enganado em incluindo arquivos remotos com código malicioso.",
    "solution": "Fase: Arquitetura e Design Quando o conjunto de objetos aceitáveis, como nomes de arquivos ou URLs, é limitado ou conhecido, criar um mapeamento de um conjunto de valores de entrada fixos (como IDs numéricos) para os nomes de arquivos ou URLs reais, e rejeitar todas as outras entradas. Por exemplo, ID 1 poderia mapear para inbox.txt e ID 2 poderia mapear para perfil. txt Características como o ESAPI AccessReferenceMap fornecer esta capacidade. Fases: Arquitetura e Design; Operação Execute seu código em um ambiente de jail ou similar sandbox que impõe limites rigorosos entre o processo e o sistema operacional. Isso pode efetivamente restringir quais arquivos podem ser acessados em um determinado diretório ou quais comandos podem ser executados pelo seu software. Exemplos de nível de sistema operacional incluem a cadeia de chroot Unix, AppArmor e SELinux. Em geral, o código gerenciado pode fornecer alguma proteção. Por exemplo, java.io.FilePermission no Java Security O gerente permite especificar restrições nas operações de arquivos. Isso pode não ser uma solução viável, e limita apenas o impacto ao sistema operacional; o resto da sua aplicação ainda pode estar sujeito a compromisso. Tenha cuidado para evitar CWE-243 e outras fraquezas relacionadas às prisões. Para o PHP, o interpretador oferece restrições como open basedir ou modo seguro que podem tornar mais difícil para um atacante escapar da aplicação. Considere também Suhosin, uma extensão PHP endurecida, que inclui várias opções que desabilitam alguns dos recursos PHP mais perigosos. Fase: Implementação Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Para nomes de arquivos, use listas de permissões rigorosas que limitem o conjunto de caracteres a ser usado. Se possível, apenas permita que um único caractere '.' no nome do arquivo evite fraquezas como CWE-23, e exclua separadores de diretórios como '/' para evitar CWE-36. Use uma lista permitida de extensões de arquivo permitidas, o que ajudará a evitar CWE-434. Fases: Arquitetura e Design; Operação Armazenar biblioteca, incluir e arquivos utilitários fora da raiz do documento web, se possível. Caso contrário, armazená-los em um diretório separado e usar as capacidades de controle de acesso do servidor web para evitar que os atacantes os solicitem diretamente. Uma prática comum é definir uma constante fixa em cada programa de chamada, depois verificar a existência da constante no arquivo biblioteca/incluir; se a constante não existir, então o arquivo foi solicitado diretamente, e pode sair imediatamente. Isso reduz significativamente a chance de um atacante ser capaz de ignorar quaisquer mecanismos de proteção que estão no programa de base, mas não nos arquivos incluem. Também reduzirá sua superfície de ataque. Fases: Arquitetura e Design; Implementação Entenda todas as áreas em que as entradas não confiáveis podem entrar em seu software: parâmetros ou argumentos, cookies, qualquer coisa lida a partir da rede, variáveis de ambiente, pesquisas DNS reversíveis, resultados de consultas, cabeçalhos de solicitação, componentes de URL, e-mail, arquivos, bancos de dados e quaisquer sistemas externos que fornecem dados para a aplicação. Lembre-se de que essas entradas podem ser obtidas indiretamente através de chamadas de API. Muitos problemas de inclusão de arquivos ocorrem porque o programador assumiu que certas entradas não poderiam ser modificadas, especialmente para cookies e componentes de URL.",
    "alert": "Inclusão de arquivos remotos",
    "alertRef": "7"
  },
  {
    "description": "O código fonte para a página atual foi divulgado pelo servidor web",
    "solution": "Certifique-se de que os arquivos de metadados Git não são implantados no servidor web ou no servidor de aplicativos",
    "alert": "Código fonte Divulgação - Git",
    "alertRef": "41"
  },
  {
    "description": "O código fonte para a página atual foi divulgado pelo servidor web",
    "solution": "Certifique-se de que os arquivos de metadados SVN não são implantados no servidor web ou no servidor de aplicativos",
    "alert": "Código de origem Divulgação - SVN",
    "alertRef": "42"
  },
  {
    "description": "A técnica de ataque Path Traversal permite que um acesso ao atacante a arquivos, diretórios e comandos que potencialmente residem fora do diretório raiz do documento web. Um atacante pode manipular uma URL de tal forma que o site irá executar ou revelar o conteúdo de arquivos arbitrários em qualquer lugar do servidor web. Qualquer dispositivo que exponha uma interface baseada em HTTP é potencialmente vulnerável ao Path Traversal.",
    "solution": "Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Para nomes de arquivos, use listas de permissões rigorosas que limitem o conjunto de caracteres a ser usado. Se possível, apenas permita que um único caractere '.' no nome do arquivo evite fraquezas e exclua separadores de diretórios como '/'. Use uma lista permitida de extensões de arquivo permitidas. Atenção: se você tentar limpar seus dados, então faça isso para que o resultado final não esteja na forma que possa ser perigosa. Um mecanismo de higienização pode remover caracteres como '.' e ';' que podem ser necessários para algumas explorações. Um atacante pode tentar enganar o mecanismo sanitizing na limpeza de dados em uma forma perigosa. Suponha que o atacante injeta um '.' dentro de um nome de arquivo (por exemplo, sensi.tiveFile) e o mecanismo de higienização remove o personagem resultando no nome de arquivo válido, sensívelFile. Se os dados de entrada são agora assumidos como seguros, então o arquivo pode ser comprometido. As entradas devem ser decodificadas e canonicalizadas para a representação interna atual da aplicação antes de serem validadas. Certifique-se de que sua aplicação não decodifica a mesma entrada duas vezes. Tais erros podem ser usados para ignorar permitir esquemas de lista introduzindo entradas perigosas após terem sido verificados. Use uma função de canonicalização de caminho incorporado (como realpath)( em C) que produz a versão canônica do nome do caminho, que efetivamente remove as sequências '.' e links simbólicos. Execute seu código usando os privilégios mais baixos que são necessários para realizar as tarefas necessárias. Se possível, crie contas isoladas com privilégios limitados que só são usados para uma única tarefa. Dessa forma, um ataque bem sucedido não dará imediatamente ao atacante acesso ao resto do software ou seu ambiente. Por exemplo, os aplicativos de banco de dados raramente precisam ser executados como o administrador do banco de dados, especialmente em operações diárias. Quando o conjunto de objetos aceitáveis, como nomes de arquivos ou URLs, é limitado ou conhecido, criar um mapeamento de um conjunto de valores de entrada fixos (como IDs numéricos) para os nomes de arquivos ou URLs reais, e rejeitar todas as outras entradas. Execute seu código em um ambiente de jail ou similar sandbox que impõe limites rigorosos entre o processo e o sistema operacional. Isso pode efetivamente restringir quais arquivos podem ser acessados em um determinado diretório ou quais comandos podem ser executados pelo seu software. Exemplos de nível de sistema operacional incluem a cadeia de chroot Unix, AppArmor e SELinux. Em geral, o código gerenciado pode fornecer alguma proteção. Por exemplo, java.io.FilePermission no Java Security O gerente permite especificar restrições nas operações de arquivos. Isso pode não ser uma solução viável, e limita apenas o impacto ao sistema operacional; o resto da sua aplicação ainda pode estar sujeito a compromisso.",
    "alert": "Código de origem Divulgação - Inclusão de arquivos",
    "alertRef": "43"
  },
  {
    "description": "Indisponível",
    "solution": "Indisponível",
    "alert": "Biblioteca JS Vulnerável (Powered by Reform.js)",
    "alertRef": "10003"
  },
  {
    "description": "O servidor devolveu uma string de banner de versão no conteúdo de resposta. Tais vazamentos de informação podem permitir que os atacantes atinjam questões específicas que impactam o produto e a versão em uso.",
    "solution": "Configure o servidor para evitar tais vazamentos de informações. Por exemplo: Sob Tomcat isso é feito através da diretiva do servidor e implementação de páginas de erro personalizadas. Em Apache isso é feito através das diretivas ServerSignature e ServerTokens.",
    "alert": "Em Folha de Informação de Banner de Página",
    "alertRef": "10009"
  },
  {
    "description": "Um cookie foi definido sem a bandeira HttpOnly, o que significa que o cookie pode ser acessado pelo JavaScript. Se um script malicioso pode ser executado nesta página, o cookie será acessível e pode ser transmitido para outro site. Se este é um cookie de sessão, então seqüestro de sessão pode ser possível.",
    "solution": "Certifique-se de que a bandeira HttpOnly está definida para todos os cookies.",
    "alert": "Cookie No Http Bandeira única",
    "alertRef": "10010"
  },
  {
    "description": "Um cookie foi definido sem a bandeira segura, o que significa que o cookie pode ser acessado através de conexões não criptografadas.",
    "solution": "Sempre que um cookie contém informações sensíveis ou é um token de sessão, deve ser sempre passado usando um canal criptografado. Certifique-se de que a bandeira segura é definida para cookies contendo tais informações confidenciais.",
    "alert": "Cookie sem bandeira segura",
    "alertRef": "10011"
  },
  {
    "description": "O cabeçalho de controle de cache não foi definido corretamente ou está faltando, permitindo que o navegador e proxies cache conteúdo. Para ativos estáticos como css, js ou arquivos de imagem que podem ser destinados, no entanto, os recursos devem ser revisados para garantir que nenhum conteúdo sensível será armazenado em cache.",
    "solution": "Para conteúdo seguro, certifique-se de que o cabeçalho HTTP de controle de cache é definido com 'no-cache, no-store, must-revalidate.' Se um activo deve ser armazenado em cache, considere a definição das directivas «public, max-age, imutável». '",
    "alert": "Reexaminar as directivas sobre o controlo do cache",
    "alertRef": "10015"
  },
  {
    "description": "A página inclui um ou mais arquivos de script de um domínio de terceiros.",
    "solution": "Certifique-se de que os arquivos de origem JavaScript sejam carregados apenas de fontes confiáveis, e as fontes não podem ser controladas pelos usuários finais do aplicativo.",
    "alert": "JavaScript para cross-Domain Inclusão do arquivo de origem",
    "alertRef": "10017"
  },
  {
    "description": "O cabeçalho Content-Type estava ausente ou vazio.",
    "solution": "Assegurar que cada página esteja definindo o valor específico e apropriado do tipo de conteúdo para o conteúdo que está sendo entregue.",
    "alert": "Falta de cabeçalho de TI",
    "alertRef": "10019"
  },
  {
    "description": "A resposta não inclui qualquer Content-Security-Policy com a diretiva ‘frame-ancestors’ ou X-Frame-Options para proteger contra ataques ‘ClickJacking’.",
    "solution": "Os navegadores da Web modernos suportam os cabeçalhos HTTP da Content-Security-Policy e X-Frame-Options. Certifique-se de que um deles é definido em todas as páginas da web retornadas pelo seu site / aplicativo. Se você espera que a página seja enquadrada apenas por páginas em seu servidor (por exemplo, é parte de um FRAMESET) então você vai querer usar SAMEORIGIN, caso contrário, se você nunca esperar que a página seja enquadrada, você deve usar DENY. Alternativamente, considere implementar a diretiva de frame-ancestors da Política de Segurança de Conteúdo.",
    "alert": "Faltando cabeçalho anti-cliquejacking",
    "alertRef": "10020-1"
  },
  {
    "description": "Os cabeçalhos X-Frame-Options (XFO) foram encontrados, uma resposta com várias entradas de cabeçalho XFO pode não ser tratada previsivelmente por todos os usuários.",
    "solution": "Certifique-se de que apenas um único cabeçalho X-Frame-Options está presente na resposta.",
    "alert": "Várias entradas de cabeçalho X-Frame-Opções",
    "alertRef": "10020-2"
  },
  {
    "description": "Uma tag META X-Frame-Options (XFO) foi encontrada, definindo XFO através de uma tag META não é explicitamente suportada pela especificação (RFC 7034.)",
    "solution": "Certifique-se de X-Frame-Options é definido através de um campo de cabeçalho de resposta. Alternativamente, considere implementar a diretiva de frame-ancestors da Política de Segurança de Conteúdo.",
    "alert": "X-Frame-Opções Definidas via META (não conforme Spec)",
    "alertRef": "10020-3"
  },
  {
    "description": "Um cabeçalho X-Frame-Options estava presente na resposta, mas o valor não foi definido corretamente.",
    "solution": "Certifique-se de que uma configuração válida seja usada em todas as páginas web retornadas pelo seu site (se você esperar que a página seja enquadrada apenas por páginas no seu servidor (por exemplo, faz parte de um FRAMESET) então você vai querer usar SAMEORIGIN, caso contrário, se você nunca esperar que a página seja enquadrada, você deve usar DENY. Alternativamente, considere implementar a diretiva de frame-ancestors da Política de Segurança de Conteúdo.",
    "alert": "X-Frame-Opções Definindo Malformado",
    "alertRef": "10020-4"
  },
  {
    "description": "O cabeçalho Anti-MIME-Sniffing X-Content-Type-Options não foi definido para ’nosniff’. Isso permite que versões mais antigas do Internet Explorer e do Chrome executem o MIME-sniffing no corpo de resposta, potencialmente fazendo com que o corpo de resposta seja interpretado e exibido como um tipo de conteúdo diferente do tipo de conteúdo declarado. As versões atuais (anteriormente 2014) e legados do Firefox usarão o tipo de conteúdo declarado (se um for definido,) em vez de executar MIME-sniffing.",
    "solution": "Certifique-se de que o aplicativo / servidor web define o cabeçalho Content-Type apropriadamente, e que ele define o cabeçalho X-Content-Type-Options para nosniff para todas as páginas da web. Se possível, certifique-se de que o usuário final usa um navegador web compatível com padrões e moderno que não executa MIME-sniffing em absoluto, ou que pode ser direcionado pelo aplicativo web / servidor web para não executar MIME-sniffing.",
    "alert": "X-Content-Type-Options Header Missing",
    "alertRef": "10021"
  },
  {
    "description": "A resposta parecia conter mensagens de erro comuns retornadas por plataformas como o ASP. NET e Web-servers como IIS e Apache. Você pode configurar a lista de mensagens de depuração comuns.",
    "solution": "Desativar mensagens de depuração antes de empurrar para a produção.",
    "alert": "Divulgação da Informação - Mensagens de erro de depuração",
    "alertRef": "10023"
  },
  {
    "description": "O pedido parecia conter informações confidenciais vazadas na URL. Isso pode violar o PCI e a maioria das políticas de conformidade organizacional. Você pode configurar a lista de strings para esta verificação para adicionar ou remover valores específicos ao seu ambiente.",
    "solution": "Não passe informações confidenciais em URIs.",
    "alert": "Divulgação de Informações - Informações Sensíveis em URL",
    "alertRef": "10024"
  },
  {
    "description": "O cabeçalho HTTP pode ter vazado um parâmetro potencialmente sensível para outro domínio. Isso pode violar o PCI e a maioria das políticas de conformidade organizacional. Você pode configurar a lista de strings para esta verificação para adicionar ou remover valores específicos ao seu ambiente.",
    "solution": "Não passe informações confidenciais em URIs.",
    "alert": "Divulgação de Informações - Informações Sensíveis no cabeçalho HTTP Referrer",
    "alertRef": "10025"
  },
  {
    "description": "Ação de forma não especificada: O parâmetro HTTP substitui o ataque potencialmente possível. Este é um problema conhecido com Java Servlets, mas outras plataformas também podem ser vulneráveis.",
    "solution": "Todos os formulários devem especificar a URL de ação.",
    "alert": "Parâmetro HTTP Override",
    "alertRef": "10026"
  },
  {
    "description": "A resposta parece conter comentários suspeitos que podem ajudar um atacante. Nota: As correspondências feitas dentro de blocos de script ou arquivos são contra todo o conteúdo não só comentários.",
    "solution": "Remova todos os comentários que retornam informações que podem ajudar um atacante e corrigir quaisquer problemas subjacentes que eles se referem.",
    "alert": "InformaÃ§Ã£o Disclosure - Suspicious Comments",
    "alertRef": "10027"
  },
  {
    "description": "Os redirecionamentos abertos são uma das vulnerabilidades OWASP 2010 Top Ten. Esta verificação analisa a entrada fornecida pelo usuário em parâmetros de cadeia de consulta e dados POST para identificar onde redirecionamentos abertos podem ser possíveis. Redirecionamentos abertos ocorrem quando um aplicativo permite a entrada aplicada pelo usuário (por exemplo, http://nottrusted.com) para controlar um redirecionamento offsite. Esta é geralmente uma maneira bastante precisa de encontrar onde os redirecionamentos 301 ou 302 podem ser explorados por spammers ou ataques de phishing.",
    "solution": "Para evitar a vulnerabilidade de redirecionamento aberto, os parâmetros do script/programa de aplicação devem ser validados antes de enviar 302 código HTTP (redirecionar) para o navegador cliente. Implementar funcionalidade de redirecionamento seguro que redireciona apenas para URI relativa, ou uma lista de domínios confiáveis",
    "alert": "Abrir Redirecionamento",
    "alertRef": "10028"
  },
  {
    "description": "Esta verificação analisa a entrada fornecida pelo usuário em parâmetros de cadeia de consulta e dados POST para identificar onde os parâmetros de cookies podem ser controlados. Isso é chamado de ataque de envenenamento de cookies, e torna-se explorável quando um atacante pode manipular o cookie de várias maneiras. Em alguns casos, isso não será explorável, no entanto, permitir que os parâmetros de URL para definir valores de cookie é geralmente considerado um bug.",
    "solution": "Não permita que a entrada do usuário controle nomes e valores de cookies. Se alguns parâmetros de string de consulta devem ser definidos em valores de cookies, certifique-se de filtrar o ponto e vírgula que pode servir como delimitadores de pares de nome/valor.",
    "alert": "Envenenamento de Cookies",
    "alertRef": "10029"
  },
  {
    "description": "Esta verificação analisa a entrada fornecida pelo usuário em parâmetros de cadeia de consulta e dados POST para identificar onde as declarações de caracteres de conteúdo-tipo ou meta tag podem ser controladas pelo usuário. Tais declarações de charset devem sempre ser declaradas pelo aplicativo. Se um atacante pode controlar a resposta charset, eles podem manipular o HTML para executar XSS ou outros ataques. Por exemplo, um atacante que controla o valor de charset do elemento é capaz de declarar UTF-7 e também é capaz de incluir carga útil suficiente controlada pelo usuário no início do documento HTML para tê-lo interpretado como UTF-7. Ao codificar sua carga útil com o UTF-7, o atacante é capaz de contornar quaisquer proteções XSS do lado do servidor e incorporar script na página.",
    "solution": "Força UTF-8 em todas as declarações de charset. Se a entrada do usuário for necessária para decidir uma declaração de charset, certifique-se de que apenas uma lista permitida é usada.",
    "alert": "Carset controlável pelo usuário",
    "alertRef": "10030"
  },
  {
    "description": "Esta verificação analisa a entrada aplicada pelo usuário em parâmetros de cadeia de consulta e dados POST para identificar onde determinados valores de atributos HTML podem ser controlados. Isso fornece detecção de hot-spot para XSS (scripting de cross-site) que exigirá mais revisão por um analista de segurança para determinar a explosabilidade.",
    "solution": "Validar todas as entradas e higienizar a saída antes de escrever para quaisquer atributos HTML.",
    "alert": "Atributo de elemento HTML controlável do usuário (XSS positivo)",
    "alertRef": "10031"
  },
  {
    "description": "Os seguintes endereços IP potenciais foram encontrados sendo serializados no campo viewstate:",
    "solution": "Verificar as informações fornecidas não é confidencial.",
    "alert": "Endereços IP potenciais encontrados no Viewstate",
    "alertRef": "10032-1"
  },
  {
    "description": "Os seguintes e-mails foram encontrados sendo serializados no campo viewstate:",
    "solution": "Verificar as informações fornecidas não é confidencial.",
    "alert": "Emails encontrados no Viewstate",
    "alertRef": "10032-2"
  },
  {
    "description": "*** EXPERIMENTAÇÃO Este site usa ASP. NET versão 1.0 ou 1.1",
    "solution": "Certifique-se de que o framework engajado ainda é suportado pela Microsoft.",
    "alert": "Versão Asp.Net antiga em uso",
    "alertRef": "10032-3"
  },
  {
    "description": "*** EXPERIMENTAÇÃO Este site usa ASP. Viewstate da NET, mas talvez sem nenhum MAC.",
    "solution": "Certifique-se de que o MAC está definido para todas as páginas neste site.",
    "alert": "Viewstate sem MAC Signature (Unsure)",
    "alertRef": "10032-4"
  },
  {
    "description": "*** EXPERIMENTAÇÃO Este site usa ASP. Viewstate da NET, mas sem nenhum MAC.",
    "solution": "Certifique-se de que o MAC está definido para todas as páginas neste site.",
    "alert": "Viewstate sem assinatura MAC (Claro)",
    "alertRef": "10032-5"
  },
  {
    "description": "*** EXPERIMENTAÇÃO Este site usa ASP. Viewstate da NET e seu valor é dividido em vários pedaços.",
    "solution": "Nenhum - os caras que executam o servidor podem ter sintonizado a configuração como esta não é a configuração padrão.",
    "alert": "Split Viewstate em uso",
    "alertRef": "10032-6"
  },
  {
    "description": "É possível visualizar uma lista dos conteúdos do diretório. As listagens do diretório podem revelar scripts ocultos, incluir arquivos, arquivos de origem de backup, etc., que são acessados para revelar informações confidenciais.",
    "solution": "Configure o servidor web para desativar a navegação do diretório.",
    "alert": "Navegação do diretório",
    "alertRef": "10033"
  },
  {
    "description": "As implementações TLS e DTLS no OpenSSL 1.0.1 antes 1.0.1g não lidam corretamente com pacotes de extensão Heartbeat, o que permite que os atacantes remotos obtenham informações confidenciais da memória do processo através de pacotes criados que acionam um buffer over-read, potencialmente divulgando informações sensíveis.",
    "solution": "Atualização para OpenSSL 1.0.1g ou posterior. Reeditar certificados HTTPS. Alterar chaves privadas assimétricas e chaves secretas compartilhadas, uma vez que estas podem ter sido comprometidas, sem nenhuma evidência de compromisso nos arquivos de log do servidor.",
    "alert": "Vulnerabilidade OpenSSL Heartbleed (Indicativo)",
    "alertRef": "10034"
  },
  {
    "description": "O HTTP Strict Transport Security (HSTS) é um mecanismo de política de segurança da web pelo qual um servidor web declara que cumprir agentes de usuário (como um navegador da web) deve interagir com ele usando apenas conexões HTTPS seguras (ou seja, HTTP em camadas sobre TLS/SSL). HSTS é um protocolo de faixa de padrões IETF e é especificado no RFC 6797.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado para aplicar o Strict-Transport-Security.",
    "alert": "Cabeçalho de segurança restrito",
    "alertRef": "10035"
  },
  {
    "description": "Indisponível",
    "solution": "Indisponível",
    "alert": "Cabeçalho de resposta de servidor HTTP",
    "alertRef": "10036"
  },
  {
    "description": "O servidor web/application está vazando informações através de um ou mais cabeçalhos de resposta HTTP “X-Powered-By”. O acesso a tais informações pode facilitar os atacantes identificando outros frameworks/componentes que sua aplicação web depende e as vulnerabilidades que tais componentes podem estar sujeitos.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado para suprimir cabeçalhos X-Powered-By.",
    "alert": "InformaÃ§Ãμes de vazamento de servidor via X-Powered-By HTTP Response Header Field(s)",
    "alertRef": "10037"
  },
  {
    "description": "A Política de Segurança do Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques, incluindo o Cross Site Scripting (XSS) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado para definir o cabeçalho Content-Security-Policy, para alcançar o suporte ideal do navegador: Content-Security-Policy para Chrome 25+, Firefox 23+ e Safari 7+, X-Content-Security-Policy para Firefox 4.0+ e Internet Explorer 10+, e X-WebKit-CSP para Chrome 14+ e Safari 6.",
    "alert": "Política de Segurança de Conteúdo (CSP) Header Not Set",
    "alertRef": "10038"
  },
  {
    "description": "O servidor está vazando informações relativas a sistemas de backend (como nomes de host ou endereços IP.) Armado com esta informação um atacante pode ser capaz de atacar outros sistemas ou mais diretamente / eficientemente atacar esses sistemas.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado para suprimir cabeçalhos X-Backend-Server.",
    "alert": "X-Backend-Server Header Information Leak",
    "alertRef": "10039"
  },
  {
    "description": "A página inclui conteúdo misto, que é acessado por conteúdo via HTTP em vez de HTTPS.",
    "solution": "Uma página que está disponível sobre SSL/TLS deve ser composta completamente de conteúdo que é transmitido por SSL/TLS. A página não deve conter qualquer conteúdo que seja transmitido por HTTP não criptografado. Isso inclui conteúdo de sites de terceiros.",
    "alert": "Páginas seguras incluem conteúdo misto",
    "alertRef": "10040"
  },
  {
    "description": "Esta verificação procura páginas HTTP inseguras que hospedam formulários HTTPS. O problema é que uma página HTTP insegura pode ser facilmente sequestrada através do MITM e o formulário HTTPS seguro pode ser substituído ou spoofed.",
    "solution": "Use HTTPS para landing pages que hospedam formulários seguros.",
    "alert": "Transição insegura HTTP para HTTPS em Form Post",
    "alertRef": "10041"
  },
  {
    "description": "Esta verificação identifica páginas HTTPS seguras que hospedam formulários HTTP inseguros. O problema é que uma página segura está transicionando para uma página insegura quando os dados são enviados através de um formulário. O usuário pode pensar que eles estão enviando dados para uma página segura quando na verdade eles não estão.",
    "solution": "Certifique-se de que os dados confidenciais sejam enviados apenas através de canais HTTPS protegidos.",
    "alert": "HTTPS para Transição Insegura HTTP em Formulário Post",
    "alertRef": "10042"
  },
  {
    "description": "Esta verificação analisa a entrada aplicada pelo usuário em parâmetros de cadeia de consulta e dados POST para identificar onde determinados valores de atributos HTML podem ser controlados. Isso fornece detecção de hot-spot para XSS (scripting de cross-site) que exigirá mais revisão por um analista de segurança para determinar a explosabilidade.",
    "solution": "Validar todas as entradas e higienizar a saída antes de escrever para qualquer Javascript em * eventos.",
    "alert": "Evento JavaScript controlável pelo usuário (XSS)",
    "alertRef": "10043"
  },
  {
    "description": "O servidor respondeu com um redirecionamento que parece fornecer uma grande resposta. Isso pode indicar que, embora o servidor tenha enviado um redirecionamento, ele também respondeu com conteúdo corporal (que pode incluir detalhes confidenciais, PII, etc.)",
    "solution": "Certifique-se de que nenhuma informação sensível é vazada através de respostas de redirecionamento. Respostas redirecionadas não devem ter quase nenhum conteúdo.",
    "alert": "Big Redirect Detected (Potential Sensitive Information Leak)",
    "alertRef": "10044"
  },
  {
    "description": "Predictable Resource Location é uma técnica de ataque usada para descobrir conteúdo e funcionalidade do site oculto. Ao fazer suposições educadas através de força bruta um atacante pode adivinhar nomes de arquivo e diretório não destinados para visualização pública. Brute forcing nomes de arquivo é fácil porque os arquivos / caminhos muitas vezes têm convenção de nomeação comum e residem em locais padrão. Estes podem incluir arquivos temporários, arquivos de backup, logs, seções do site administrativo, arquivos de configuração, aplicativos de demonstração e arquivos de amostra. Esses arquivos podem divulgar informações confidenciais sobre o site, internos de aplicativos web, informações de banco de dados, senhas, nomes de máquinas, caminhos de arquivo para outras áreas sensíveis, etc...",
    "solution": "Aplique as autorizações de controle de acesso adequadas para cada acesso a todas as URLs, scripts ou arquivos restritos. Considere usar frameworks baseados em MVC, como Struts.",
    "alert": "Código de origem Divulgação - pasta /WEB-INF",
    "alertRef": "10045"
  },
  {
    "description": "O conteúdo que foi inicialmente acessado via HTTPS (ou seja: usando criptografia SSL/TLS) também é acessível via HTTP (sem criptografia).",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado para servir apenas esse conteúdo via HTTPS. Considere a implementação de HTTP Strict Transport Security.",
    "alert": "Conteúdo HTTPS Disponível via HTTP",
    "alertRef": "10047"
  },
  {
    "description": "O servidor está executando uma versão do shell Bash que permite que os atacantes remotos executem o código arbitrário",
    "solution": "Atualizar Bash no servidor para a versão mais recente",
    "alert": "Execução de Código Remoto - Shell Shock",
    "alertRef": "10048"
  },
  {
    "description": "Indisponível",
    "solution": "Indisponível",
    "alert": "Caqueabilidade de Conteúdo",
    "alertRef": "10049"
  },
  {
    "description": "O conteúdo foi recuperado de um cache compartilhado. Se os dados de resposta são sensíveis, pessoais ou específicos do usuário, isso pode resultar em informações confidenciais vazadas. Em alguns casos, isso pode até resultar em um usuário ganhando controle completo da sessão de outro usuário, dependendo da configuração dos componentes de cache em uso em seu ambiente. Este é principalmente um problema em que servidores de cache como caches “proxy” são configurados na rede local. Esta configuração é tipicamente encontrada em ambientes corporativos ou educacionais, por exemplo.",
    "solution": "Validar que a resposta não contém informações confidenciais, pessoais ou específicas do usuário. Se o fizer, considere o uso dos seguintes cabeçalhos de resposta HTTP, para limitar ou impedir que o conteúdo seja armazenado e recuperado do cache por outro usuário: Cache-Control: no-cache, no-store, must-revalidate, privado Pragma: no-cache Expires: 0 Esta configuração direciona servidores de cache compatíveis HTTP 1.0 e HTTP 1.1 para não armazenar a resposta e não recuperar a resposta (sem validação) do cache, em resposta a uma solicitação semelhante.",
    "alert": "Retrieved de Cache",
    "alertRef": "10050"
  },
  {
    "description": "O servidor web é configurado para servir respostas a URLs ambíguas de uma maneira que é provável que leve à confusão sobre o “caminho relativo” correto para a URL. Recursos (CSS, imagens, etc.) também são especificados na resposta da página usando URLs relativas, em vez de absolutas. Em um ataque, se o navegador da web analisa a resposta “cross-content” de uma forma permissiva, ou pode ser enganado em permissivamente analisando a resposta “cross-content”, usando técnicas como enquadramento, então o navegador da web pode ser enganado em interpretar HTML como CSS (ou outros tipos de conteúdo), levando a uma vulnerabilidade XSS.",
    "solution": "Servidores e frameworks da Web devem ser atualizados para serem configurados para não servir respostas a URLs ambíguas de tal forma que o caminho relativo de tais URLs poderia ser mal interpretado por componentes do lado do cliente ou do lado do servidor. Dentro da aplicação, o uso correto do <base> A tag HTML na resposta HTTP especificará inequivocamente a URL base para todas as URLs relativas no documento. Use o cabeçalho de resposta HTTP Content-Type para tornar mais difícil para o atacante forçar o navegador da web a interpretar mal o tipo de conteúdo da resposta. Use o cabeçalho de resposta HTTP 'X-Content-Type-Options: nosniff' para evitar que o navegador da web fareje o tipo de conteúdo da resposta. Use um DOCTYPE moderno como !<'doctype html>' para evitar que a página seja renderizada no navegador da Web usando 'Modo de Perguntas', uma vez que isso resulta no tipo de conteúdo sendo ignorado pelo navegador da web. Especifique o cabeçalho de resposta HTTP X-Frame-Options para evitar que o Modo Quirks seja ativado no navegador da web usando ataques de enquadramento.",
    "alert": "Confusão relativa do caminho",
    "alertRef": "10051"
  },
  {
    "description": "O servidor está vazando informações através do cabeçalho de resposta X-ChromeLogger-Data (ou X-ChromePhp-Data). O conteúdo de tais cabeçalhos pode ser personalizado pelo desenvolvedor, no entanto, não é incomum encontrar: localizações do sistema de arquivos de servidor, declarações vhost, etc.",
    "solution": "Desativar esta funcionalidade na Produção quando pode vazar informações que podem ser aproveitadas por um atacante. Alternativamente, certifique-se de que o uso da funcionalidade está vinculado a uma verificação de autorização forte e apenas disponível para administradores ou pessoal de suporte para fins de solução de problemas não usuários gerais.",
    "alert": "X-ChromeLogger-Data (XCOLD) Informações sobre cabeçalho",
    "alertRef": "10052"
  },
  {
    "description": "O filtro byterange em versões anteriores do Apache HTTP Server permite que os atacantes remotos causem uma negação de serviço (memória e exaustão de CPU) através de um cabeçalho de solicitação Range que identifica vários intervalos de sobreposição. Esta questão foi explorada na natureza em agosto de 2011.",
    "solution": "Atualize seu Servidor Apache para uma versão estável. Soluções alternativas ou soluções alternativas são descritas nas referências.",
    "alert": "Apache Range Header DoS (CVE-2011-3192)",
    "alertRef": "10053"
  },
  {
    "description": "Um cookie foi definido sem o atributo SameSite, o que significa que o cookie pode ser enviado como resultado de uma solicitação de “local cruzado”. O atributo SameSite é uma medida contra eficaz para falsificação de pedidos no local, inclusão de scripts no local e ataques de tempo.",
    "solution": "Certifique-se de que o atributo SameSite está definido para lax ou de forma ideal estrita para todos os cookies.",
    "alert": "Cookie sem SameSite Attribute",
    "alertRef": "10054"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: X-Content-Security-Policy",
    "alertRef": "10055-1"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: X-WebKit-CSP",
    "alertRef": "10055-2"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: Avisos",
    "alertRef": "10055-3"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: Diretiva de Wildcard",
    "alertRef": "10055-4"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: script-src unsafe-inline",
    "alertRef": "10055-5"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: estilo-src inseguro-inline",
    "alertRef": "10055-6"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: script-src unsafe-hashes",
    "alertRef": "10055-7"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: estilo-src inseguro-hashes",
    "alertRef": "10055-8"
  },
  {
    "description": "Política de Segurança de Conteúdo (CSP) é uma camada adicional de segurança que ajuda a detectar e mitigar certos tipos de ataques. Incluindo (mas não limitado a) Cross Site Scripting (XSS,) e ataques de injeção de dados. Esses ataques são usados para tudo, desde roubo de dados até desfiguração do site ou distribuição de malware. CSP fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site declarem fontes aprovadas de conteúdo que os navegadores devem ser autorizados a carregar nessa página - tipos cobertos são JavaScript, CSS, quadros HTML, fontes, imagens e objetos embeddable tais como applets Java, ActiveX, arquivos de áudio e vídeo.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado corretamente para definir o cabeçalho Content-Security-Policy.",
    "alert": "CSP: Política malformada (Non-ASCII)",
    "alertRef": "10055-9"
  },
  {
    "description": "A resposta continha um cabeçalho X-Debug-Token ou X-Debug-Token-Link. Isso indica que o Profiler da Symfony pode estar em uso e expor dados confidenciais.",
    "solution": "Limite o acesso ao Profiler da Symfony, seja através de autenticação/autorização ou limitação da inclusão do cabeçalho para clientes específicos (por IP, etc.)",
    "alert": "X-Debug-Token Information Leak",
    "alertRef": "10056"
  },
  {
    "description": "Um hash de um nome de usuário (admin) foi encontrado na resposta. Isso pode indicar que o aplicativo está sujeito a uma vulnerabilidade Insecure Direct Object Reference (IDOR). Os testes manuais serão necessários para ver se essa descoberta pode ser abusada.",
    "solution": "Use por usuário ou sessão referências de objetos indiretas (crie um mapeamento temporário no momento do uso.) Ou, certifique-se de que cada uso de uma referência de objeto direto esteja vinculado a uma verificação de autorização para garantir que o usuário esteja autorizado para o objeto solicitado.",
    "alert": "Nome de usuário Hash Found",
    "alertRef": "10057"
  },
  {
    "description": "Um pedido que foi originalmente observado como um POST também foi aceito como um GET. Esta questão não representa uma fraqueza de segurança para si, no entanto, pode facilitar a simplificação de outros ataques. Por exemplo, se o POST original está sujeito a Scripting Cross-Site (XSS,) então este achado pode indicar que um XSS simplificado (baseado em GET) também pode ser possível.",
    "solution": "Certifique-se de que apenas POST é aceito onde POST é esperado.",
    "alert": "GET para POST",
    "alertRef": "10058"
  },
  {
    "description": "Servidor vaza informações via “X-AspNet-Version”/“X-AspNetMvc-Version” campo de cabeçalho de resposta HTTP (s.)",
    "solution": "Configure o servidor para que não retorne esses cabeçalhos.",
    "alert": "X-AspNet-Version Header de resposta",
    "alertRef": "10061"
  },
  {
    "description": "A resposta contém informações pessoalmente identificáveis, como o número CC, SSN e dados sensíveis semelhantes.",
    "solution": "Indisponível",
    "alert": "POLÍTICA Divulgação",
    "alertRef": "10062"
  },
  {
    "description": "Política de permissões Header é uma camada adicional de segurança que ajuda a restringir de acesso não autorizado ou uso de recursos de navegador / cliente por recursos da web. Esta política garante a privacidade do usuário limitando ou especificando os recursos dos navegadores podem ser usados pelos recursos da web. Política de Permissões fornece um conjunto de cabeçalhos HTTP padrão que permitem que os proprietários do site limite quais características de navegadores podem ser usados pela página, tais como câmera, microfone, localização, tela cheia etc.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado para definir o cabeçalho Permissions-Policy.",
    "alert": "Cabeçalho de política de permissões não definido",
    "alertRef": "10063-1"
  },
  {
    "description": "O cabeçalho foi renomeado para Permissions-Policy.",
    "solution": "Certifique-se de que seu servidor web, servidor de aplicativos, balanceador de carga, etc. está configurado para definir o cabeçalho Permissions-Policy em vez do cabeçalho Feature-Policy.",
    "alert": "Conjunto de cabeçalho de política de recursos desprezados",
    "alertRef": "10063-2"
  },
  {
    "description": "Indisponível",
    "solution": "Indisponível",
    "alert": "Uso de SAML",
    "alertRef": "10070"
  },
  {
    "description": "Os dados codificados Base64 foram divulgados pelo servidor de aplicativos/web. Nota: no interesse do desempenho nem todas as cadeias de caracteres base64 na resposta foram analisadas individualmente, toda a resposta deve ser analisada pela equipe de analista/segurança/developer(s.)",
    "solution": "Confirma manualmente que os dados Base64 não vazam informações confidenciais, e que os dados não podem ser agregados/usados para explorar outras vulnerabilidades.",
    "alert": "Divulgação Base64",
    "alertRef": "10094"
  },
  {
    "description": "Um backup do arquivo foi divulgado pelo servidor web",
    "solution": "Aplique as autorizações de controle de acesso adequadas para cada acesso a todas as URLs, scripts ou arquivos restritos. Considere usar frameworks baseados em MVC, como Struts.",
    "alert": "Disco de arquivo de backup",
    "alertRef": "10095"
  },
  {
    "description": "Um timestamp foi divulgado pelo aplicativo / servidor web",
    "solution": "Confirma manualmente que os dados do timestamp não são sensíveis, e que os dados não podem ser agregados para divulgar padrões exploráveis.",
    "alert": "Divulgação de timestamp",
    "alertRef": "10096"
  },
  {
    "description": "Um hash foi divulgado pelo servidor web.",
    "solution": "Certifique-se de que hashes que são usados para proteger credenciais ou outros recursos não são vazados pelo servidor web ou banco de dados. Normalmente não há exigência de hashes de senha para ser acessível ao navegador da web.",
    "alert": "Disclograma de Hash",
    "alertRef": "10097"
  },
  {
    "description": "O carregamento de dados do navegador web pode ser possível, devido a uma configuração incorreta de compartilhamento de recursos de origem cruzada (CORS) no servidor web",
    "solution": "Certifique-se de que os dados confidenciais não estão disponíveis de forma não autenticada (usando a lista branca do endereço IP, por exemplo). Configurar o cabeçalho HTTP Access-Control-Allow-Origin para um conjunto mais restritivo de domínios, ou remover todos os cabeçalhos CORS inteiramente, para permitir que o navegador da Web para impor a mesma política de origem (SOP) de uma forma mais restritiva.",
    "alert": "Desconfiguração de domínios cruzados",
    "alertRef": "10098"
  },
  {
    "description": "Código de fonte de aplicação foi divulgado pelo servidor web",
    "solution": "Certifique-se de que a aplicação Código de fonte não está disponível com extensões alternativas, e garantir que o código fonte não está presente em outros arquivos ou dados implantados no servidor web, ou servido pelo servidor web.",
    "alert": "Código de origem Divulgação",
    "alertRef": "10099"
  },
  {
    "description": "A imagem foi encontrada para conter informações de localização incorporadas, como coordenadas GPS ou outra exposição de privacidade, como o número de série da câmera. Dependendo do contexto da imagem no site, esta informação pode expor detalhes privados dos usuários de um site. Por exemplo, um site que permite aos usuários carregar fotos de perfil tiradas em casa pode expor o endereço da casa.",
    "solution": "Antes de permitir que as imagens sejam armazenadas no servidor e/ou transmitidas ao navegador, tire as informações de localização incorporadas da imagem. Isso pode significar remover todos os dados Exif ou apenas o componente GPS. Outros dados, como números de série, também devem ser removidos.",
    "alert": "Image Exposes Localização ou Dados de Privacidade",
    "alertRef": "10103"
  },
  {
    "description": "A autenticação básica ou digerir HTTP foi usada em uma conexão não segura. As credenciais podem ser lidas e depois reutilizadas por alguém com acesso à rede.",
    "solution": "Proteja a conexão usando HTTPS ou use um mecanismo de autenticação mais forte",
    "alert": "Autenticação fraca Método",
    "alertRef": "10105"
  },
  {
    "description": "O site só é servido em HTTP e não HTTPS.",
    "solution": "Configurar seu servidor de web ou aplicativos para usar SSL (https.)",
    "alert": "HTTP Apenas Site",
    "alertRef": "10106"
  },
  {
    "description": "O servidor iniciou uma solicitação proxied através do proxy especificado no cabeçalho HTTP Proxy da solicitação. Httpoxy normalmente afeta o código em execução em CGI ou CGI como ambientes. Isso pode permitir que os atacantes:",
    "solution": "A melhor mitigação imediata é bloquear cabeçalhos de pedido Proxy o mais cedo possível, e antes que eles atinjam sua aplicação.",
    "alert": "Httpoxy - Uso de Cabeçalho Proxy",
    "alertRef": "101"
  },
  {
    "description": "Pelo menos um link nesta página é vulnerável ao tabnabbing Reverse, pois usa um atributo de destino sem usar as palavras-chave “noopener” e “noreferrer” no atributo “rel”, que permite que a página de destino tome o controle desta página.",
    "solution": "Não use um atributo target, ou se você tiver que adicionar também o atributo: rel='noopener noreferrer. '",
    "alert": "Tabnabbing reverso",
    "alertRef": "10108"
  },
  {
    "description": "A aplicação parece ser uma aplicação web moderna. Se você precisa explorá-lo automaticamente, então o Ajax Spider pode bem ser mais eficaz do que o padrão.",
    "solution": "Este é um alerta informativo e, portanto, não são necessárias alterações.",
    "alert": "Aplicação Web moderna",
    "alertRef": "10109"
  },
  {
    "description": "Uma função JS perigosa parece estar em uso que deixaria o site vulnerável.",
    "solution": "Veja as referências para conselhos de segurança sobre o uso dessas funções.",
    "alert": "Funções JS perigosas",
    "alertRef": "10110"
  },
  {
    "description": "Uma falsificação de solicitação cruzada é um ataque que envolve forçar uma vítima a enviar uma solicitação HTTP para um destino sem seu conhecimento ou intenção, a fim de executar uma ação como vítima. A causa subjacente é a funcionalidade de aplicação usando ações previsível URL / forma de uma forma repetível. A natureza do ataque é que a CSRF explora a confiança que um site tem para um usuário. Em contraste, scripting cross-site (XSS) explora a confiança que um usuário tem para um site. Como XSS, ataques de CSRF não são necessariamente cross-site, mas podem ser. A falsificação de pedidos cruzados também é conhecida como CSRF, XSRF, ataque de um clique, equitação de sessão, deputado confuso e surf do mar.",
    "solution": "Fase: Arquitetura e Design Use uma biblioteca ou estrutura vetada que não permita que essa fraqueza ocorra ou forneça construções que tornem essa fraqueza mais fácil de evitar. Por exemplo, use pacotes anti-CSRF como o OWASP CSRFGuard. Fase: Implementação Certifique-se de que sua aplicação está livre de problemas de script cross-site, porque a maioria das defesas CSRF podem ser ignoradas usando script controlado por atacante. Fase: Arquitetura e Design Gerar uma nona única para cada forma, colocar o nonce no formulário e verificar o nonce após o recebimento do formulário. Certifique-se de que a nonce não é previsível (CWE-330.) Note que isso pode ser ignorado usando XSS. Identificar operações especialmente perigosas. Quando o usuário executa uma operação perigosa, envie uma solicitação de confirmação separada para garantir que o usuário pretenda executar essa operação. Note que isso pode ser ignorado usando XSS. Use o controle ESAPI Session Management. Este controle inclui um componente para CSRF. Não use o método GET para qualquer solicitação que desencadeie uma mudança de estado. Fase: Implementação Verifique o cabeçalho HTTP Referer para ver se a solicitação originou de uma página esperada. Isso pode quebrar a funcionalidade legítima, porque os usuários ou proxies podem ter desativado o envio do Referer por razões de privacidade.",
    "alert": "Ausência de Anti-CSRF Tokens",
    "alertRef": "10202"
  },
  {
    "description": "Uma falsificação de solicitação cruzada é um ataque que envolve forçar uma vítima a enviar uma solicitação HTTP para um destino sem seu conhecimento ou intenção, a fim de executar uma ação como vítima. A causa subjacente é a funcionalidade de aplicação usando ações previsível URL / forma de uma forma repetível. A natureza do ataque é que a CSRF explora a confiança que um site tem para um usuário. Em contraste, scripting cross-site (XSS) explora a confiança que um usuário tem para um site. Como XSS, ataques de CSRF não são necessariamente cross-site, mas podem ser. A falsificação de pedidos cruzados também é conhecida como CSRF, XSRF, ataque de um clique, equitação de sessão, deputado confuso e surf do mar.",
    "solution": "Fase: Arquitetura e Design Use uma biblioteca ou estrutura vetada que não permita que essa fraqueza ocorra ou forneça construções que tornem essa fraqueza mais fácil de evitar. Por exemplo, use pacotes anti-CSRF como o OWASP CSRFGuard. Fase: Implementação Certifique-se de que sua aplicação está livre de problemas de script cross-site, porque a maioria das defesas CSRF podem ser ignoradas usando script controlado por atacante. Fase: Arquitetura e Design Gerar uma nona única para cada forma, colocar o nonce no formulário e verificar o nonce após o recebimento do formulário. Certifique-se de que a nonce não é previsível (CWE-330.) Note que isso pode ser ignorado usando XSS. Identificar operações especialmente perigosas. Quando o usuário executa uma operação perigosa, envie uma solicitação de confirmação separada para garantir que o usuário pretenda executar essa operação. Note que isso pode ser ignorado usando XSS. Use o controle ESAPI Session Management. Este controle inclui um componente para CSRF. Não use o método GET para qualquer solicitação que desencadeie uma mudança de estado. Fase: Implementação Verifique o cabeçalho HTTP Referer para ver se a solicitação originou de uma página esperada. Isso pode quebrar a funcionalidade legítima, porque os usuários ou proxies podem ter desativado o envio do Referer por razões de privacidade.",
    "alert": "Anti-CSRF Verificação de fichas",
    "alertRef": "20012"
  },
  {
    "description": "Os ataques de Poluição do Parâmetro HTTP (HPP) consistem em injetar delimitadores de cadeia de consulta codificados em outros parâmetros existentes. Se um aplicativo da web não higienizar corretamente a entrada do usuário, um usuário malicioso pode comprometer a lógica do aplicativo para executar ataques do lado do cliente ou do lado do servidor. Uma consequência dos ataques de HPP é que o atacante pode potencialmente substituir os parâmetros HTTP existentes de código rígido para modificar o comportamento de uma aplicação, ignorar os pontos de verificação de validação de entrada e acessar e possivelmente explorar variáveis que podem estar fora do alcance direto.",
    "solution": "Higienizar adequadamente a entrada do usuário para delimitadores de parâmetros",
    "alert": "Poluição do parâmetro HTTP",
    "alertRef": "20014"
  },
  {
    "description": "A implementação do TLS no OpenSSL 1.0.1 antes de 1.0.1g não lida corretamente com pacotes de extensão Heartbeat, o que permite que os atacantes remotos obtenham informações confidenciais da memória do processo através de pacotes criados que acionam um buffer over-read, potencialmente divulgando informações sensíveis.",
    "solution": "Atualização para OpenSSL 1.0.1g ou posterior. Reeditar certificados HTTPS. Alterar chaves privadas assimétricas e chaves secretas compartilhadas, uma vez que estas podem ter sido comprometidas, sem nenhuma evidência de compromisso nos arquivos de log do servidor.",
    "alert": "OpenSSL com coração Vulnerabilidade",
    "alertRef": "20015"
  },
  {
    "description": "O manuseio de entrada inadequado é uma das fraquezas mais comuns identificadas em aplicações hoje. A entrada mal tratada é uma causa principal por trás das vulnerabilidades críticas que existem em sistemas e aplicações.",
    "solution": "Fase: Arquitetura e Design Use um framework de validação de entrada, como Struts ou a API de validação OWASP ESAPI. Entenda todas as áreas em que as entradas não confiáveis podem entrar em seu software: parâmetros ou argumentos, cookies, qualquer coisa lida a partir da rede, variáveis de ambiente, pesquisas DNS reversíveis, resultados de consultas, cabeçalhos de solicitação, componentes de URL, e-mail, arquivos, bancos de dados e quaisquer sistemas externos que fornecem dados para a aplicação. Lembre-se de que essas entradas podem ser obtidas indiretamente através de chamadas de API. Para quaisquer verificações de segurança realizadas no lado do cliente, certifique-se de que essas verificações são duplicadas no lado do servidor. Os atacantes podem contornar as verificações do lado do cliente modificando os valores após as verificações terem sido realizadas, ou alterando o cliente para remover completamente as verificações do lado do cliente. Em seguida, esses valores modificados seriam submetidos ao servidor. Mesmo que as verificações do lado do cliente forneçam benefícios mínimos em relação à segurança do lado do servidor, elas ainda são úteis. Primeiro, eles podem suportar a detecção de intrusão. Se o servidor receber entrada que deve ter sido rejeitada pelo cliente, então pode ser uma indicação de um ataque. Em segundo lugar, verificação de erros do lado do cliente pode fornecer feedback útil ao usuário sobre as expectativas de entrada válida. Em terceiro lugar, pode haver uma redução no tempo de processamento do lado do servidor para erros de entrada acidentais, embora isso seja tipicamente uma pequena economia. Não confie exclusivamente na validação de lista de negação para detectar entrada maliciosa ou para codificar a saída. Há muitas maneiras de codificar o mesmo personagem, então você provavelmente vai perder algumas variantes. Quando sua aplicação combina dados de várias fontes, execute a validação após as fontes terem sido combinadas. Os elementos de dados individuais podem passar a etapa de validação, mas violar as restrições pretendidas após terem sido combinadas. Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Fase: Implementação Tenha especialmente cuidado para validar sua entrada quando você invoca o código que cruza os limites da linguagem, como de uma linguagem interpretada para o código nativo. Isso poderia criar uma interação inesperada entre os limites da linguagem. Certifique-se de que você não está violando nenhuma das expectativas da linguagem com que você está interfacing. Por exemplo, mesmo que Java não seja suscetível a fluxos de buffer, fornecer um grande argumento em uma chamada ao código nativo pode desencadear um transbordamento. Converta diretamente seu tipo de entrada no tipo de dados esperado, como usar uma função de conversão que traduz uma string em um número. Depois de converter para o tipo de dados esperado, certifique-se de que os valores da entrada estejam dentro da faixa esperada de valores permitidos e que as consistências multi-campo sejam mantidas. As entradas devem ser decodificadas e canonicalizadas para a representação interna atual da aplicação antes de serem validadas. Certifique-se de que sua aplicação não decodifica inadvertidamente a mesma entrada duas vezes. Tais erros podem ser usados para ignorar permitir esquemas de lista introduzindo entradas perigosas após terem sido verificados. Use bibliotecas como o controle de Canonicalização OWASP ESAPI. Considere realizar canonicalização repetida até que sua entrada não mude mais. Isso evitará cenários de dupla decodificação e semelhantes, mas pode modificar inadvertidamente as entradas que podem conter conteúdo perigoso corretamente codificado. Ao trocar dados entre componentes, certifique-se de que ambos os componentes estão usando a mesma codificação de caracteres. Certifique-se de que a codificação adequada é aplicada em cada interface. Explicitamente definir a codificação que você está usando sempre que o protocolo permite que você faça isso.",
    "alert": "Código fonte Divulgação - CVE-2012-1823",
    "alertRef": "20017"
  },
  {
    "description": "O manuseio de entrada inadequado é uma das fraquezas mais comuns identificadas em aplicações hoje. A entrada mal tratada é uma causa principal por trás das vulnerabilidades críticas que existem em sistemas e aplicações.",
    "solution": "Fase: Arquitetura e Design Use um framework de validação de entrada, como Struts ou a API de validação OWASP ESAPI. Entenda todas as áreas em que as entradas não confiáveis podem entrar em seu software: parâmetros ou argumentos, cookies, qualquer coisa lida a partir da rede, variáveis de ambiente, pesquisas DNS reversíveis, resultados de consultas, cabeçalhos de solicitação, componentes de URL, e-mail, arquivos, bancos de dados e quaisquer sistemas externos que fornecem dados para a aplicação. Lembre-se de que essas entradas podem ser obtidas indiretamente através de chamadas de API. Para quaisquer verificações de segurança realizadas no lado do cliente, certifique-se de que essas verificações são duplicadas no lado do servidor. Os atacantes podem contornar as verificações do lado do cliente modificando os valores após as verificações terem sido realizadas, ou alterando o cliente para remover completamente as verificações do lado do cliente. Em seguida, esses valores modificados seriam submetidos ao servidor. Mesmo que as verificações do lado do cliente forneçam benefícios mínimos em relação à segurança do lado do servidor, elas ainda são úteis. Primeiro, eles podem suportar a detecção de intrusão. Se o servidor receber entrada que deve ter sido rejeitada pelo cliente, então pode ser uma indicação de um ataque. Em segundo lugar, verificação de erros do lado do cliente pode fornecer feedback útil ao usuário sobre as expectativas de entrada válida. Em terceiro lugar, pode haver uma redução no tempo de processamento do lado do servidor para erros de entrada acidentais, embora isso seja tipicamente uma pequena economia. Não confie exclusivamente na validação de lista de negação para detectar entrada maliciosa ou para codificar a saída. Há muitas maneiras de codificar o mesmo personagem, então você provavelmente vai perder algumas variantes. Quando sua aplicação combina dados de várias fontes, execute a validação após as fontes terem sido combinadas. Os elementos de dados individuais podem passar a etapa de validação, mas violar as restrições pretendidas após terem sido combinadas. Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Fase: Implementação Tenha especialmente cuidado para validar sua entrada quando você invoca o código que cruza os limites da linguagem, como de uma linguagem interpretada para o código nativo. Isso poderia criar uma interação inesperada entre os limites da linguagem. Certifique-se de que você não está violando nenhuma das expectativas da linguagem com que você está interfacing. Por exemplo, mesmo que Java não seja suscetível a fluxos de buffer, fornecer um grande argumento em uma chamada ao código nativo pode desencadear um transbordamento. Converta diretamente seu tipo de entrada no tipo de dados esperado, como usar uma função de conversão que traduz uma string em um número. Depois de converter para o tipo de dados esperado, certifique-se de que os valores da entrada estejam dentro da faixa esperada de valores permitidos e que as consistências multi-campo sejam mantidas. As entradas devem ser decodificadas e canonicalizadas para a representação interna atual da aplicação antes de serem validadas. Certifique-se de que sua aplicação não decodifica inadvertidamente a mesma entrada duas vezes. Tais erros podem ser usados para ignorar permitir esquemas de lista introduzindo entradas perigosas após terem sido verificados. Use bibliotecas como o controle de Canonicalização OWASP ESAPI. Considere realizar canonicalização repetida até que sua entrada não mude mais. Isso evitará cenários de dupla decodificação e semelhantes, mas pode modificar inadvertidamente as entradas que podem conter conteúdo perigoso corretamente codificado. Ao trocar dados entre componentes, certifique-se de que ambos os componentes estão usando a mesma codificação de caracteres. Certifique-se de que a codificação adequada é aplicada em cada interface. Explicitamente definir a codificação que você está usando sempre que o protocolo permite que você faça isso.",
    "alert": "Execução de código remoto - CVE-2012-1823",
    "alertRef": "20018"
  },
  {
    "description": "Os redirecionadores de URL representam uma funcionalidade comum empregada por sites para encaminhar um pedido de entrada para um recurso alternativo. Isso pode ser feito por uma variedade de razões e muitas vezes é feito para permitir que os recursos sejam movidos dentro da estrutura do diretório e para evitar quebra de funcionalidade para os usuários que solicitam o recurso em seu local anterior. Os redirecionadores de URL também podem ser usados para implementar balanceamento de carga, alavancando URLs abreviadas ou gravando links de saída. É esta última implementação que é frequentemente usada em ataques de phishing como descrito no exemplo abaixo. Os redirecionadores de URL não representam necessariamente uma vulnerabilidade de segurança direta, mas podem ser abusados por atacantes tentando as vítimas de engenheiro social em acreditar que eles estão navegando para um site diferente do destino verdadeiro.",
    "solution": "Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Use uma lista de permissões de URLs ou domínios aprovados para ser usado para redirecionamento. Use uma página de aviso intermediário que fornece ao usuário um aviso claro de que eles estão deixando seu site. Implemente um longo prazo antes do redirecionamento ocorrer, ou forçar o usuário a clicar no link. Tenha cuidado para evitar problemas do XSS ao gerar a página de aviso. Quando o conjunto de objetos aceitáveis, como nomes de arquivos ou URLs, é limitado ou conhecido, criar um mapeamento de um conjunto de valores de entrada fixos (como IDs numéricos) para os nomes de arquivos ou URLs reais, e rejeitar todas as outras entradas. Por exemplo, ID 1 poderia mapear para /login.asp e ID 2 poderia mapear para http://www.example.com Características como o ESAPI AccessReferenceMap fornecem esta capacidade. Entenda todas as áreas em que as entradas não confiáveis podem entrar em seu software: parâmetros ou argumentos, cookies, qualquer coisa lida a partir da rede, variáveis de ambiente, pesquisas DNS reversíveis, resultados de consultas, cabeçalhos de solicitação, componentes de URL, e-mail, arquivos, bancos de dados e quaisquer sistemas externos que fornecem dados para a aplicação. Lembre-se de que essas entradas podem ser obtidas indiretamente através de chamadas de API. Muitos problemas de redirecionamento aberto ocorrem porque o programador assumiu que certas entradas não poderiam ser modificadas, tais como cookies e campos de formulário ocultos.",
    "alert": "Redirecionamento externo",
    "alertRef": "20019-1"
  },
  {
    "description": "Os redirecionadores de URL representam uma funcionalidade comum empregada por sites para encaminhar um pedido de entrada para um recurso alternativo. Isso pode ser feito por uma variedade de razões e muitas vezes é feito para permitir que os recursos sejam movidos dentro da estrutura do diretório e para evitar quebra de funcionalidade para os usuários que solicitam o recurso em seu local anterior. Os redirecionadores de URL também podem ser usados para implementar balanceamento de carga, alavancando URLs abreviadas ou gravando links de saída. É esta última implementação que é frequentemente usada em ataques de phishing como descrito no exemplo abaixo. Os redirecionadores de URL não representam necessariamente uma vulnerabilidade de segurança direta, mas podem ser abusados por atacantes tentando as vítimas de engenheiro social em acreditar que eles estão navegando para um site diferente do destino verdadeiro.",
    "solution": "Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Use uma lista de permissões de URLs ou domínios aprovados para ser usado para redirecionamento. Use uma página de aviso intermediário que fornece ao usuário um aviso claro de que eles estão deixando seu site. Implemente um longo prazo antes do redirecionamento ocorrer, ou forçar o usuário a clicar no link. Tenha cuidado para evitar problemas do XSS ao gerar a página de aviso. Quando o conjunto de objetos aceitáveis, como nomes de arquivos ou URLs, é limitado ou conhecido, criar um mapeamento de um conjunto de valores de entrada fixos (como IDs numéricos) para os nomes de arquivos ou URLs reais, e rejeitar todas as outras entradas. Por exemplo, ID 1 poderia mapear para /login.asp e ID 2 poderia mapear para http://www.example.com Características como o ESAPI AccessReferenceMap fornecem esta capacidade. Entenda todas as áreas em que as entradas não confiáveis podem entrar em seu software: parâmetros ou argumentos, cookies, qualquer coisa lida a partir da rede, variáveis de ambiente, pesquisas DNS reversíveis, resultados de consultas, cabeçalhos de solicitação, componentes de URL, e-mail, arquivos, bancos de dados e quaisquer sistemas externos que fornecem dados para a aplicação. Lembre-se de que essas entradas podem ser obtidas indiretamente através de chamadas de API. Muitos problemas de redirecionamento aberto ocorrem porque o programador assumiu que certas entradas não poderiam ser modificadas, tais como cookies e campos de formulário ocultos.",
    "alert": "Redirecionamento externo",
    "alertRef": "20019-2"
  },
  {
    "description": "Os redirecionadores de URL representam uma funcionalidade comum empregada por sites para encaminhar um pedido de entrada para um recurso alternativo. Isso pode ser feito por uma variedade de razões e muitas vezes é feito para permitir que os recursos sejam movidos dentro da estrutura do diretório e para evitar quebra de funcionalidade para os usuários que solicitam o recurso em seu local anterior. Os redirecionadores de URL também podem ser usados para implementar balanceamento de carga, alavancando URLs abreviadas ou gravando links de saída. É esta última implementação que é frequentemente usada em ataques de phishing como descrito no exemplo abaixo. Os redirecionadores de URL não representam necessariamente uma vulnerabilidade de segurança direta, mas podem ser abusados por atacantes tentando as vítimas de engenheiro social em acreditar que eles estão navegando para um site diferente do destino verdadeiro.",
    "solution": "Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Use uma lista de permissões de URLs ou domínios aprovados para ser usado para redirecionamento. Use uma página de aviso intermediário que fornece ao usuário um aviso claro de que eles estão deixando seu site. Implemente um longo prazo antes do redirecionamento ocorrer, ou forçar o usuário a clicar no link. Tenha cuidado para evitar problemas do XSS ao gerar a página de aviso. Quando o conjunto de objetos aceitáveis, como nomes de arquivos ou URLs, é limitado ou conhecido, criar um mapeamento de um conjunto de valores de entrada fixos (como IDs numéricos) para os nomes de arquivos ou URLs reais, e rejeitar todas as outras entradas. Por exemplo, ID 1 poderia mapear para /login.asp e ID 2 poderia mapear para http://www.example.com Características como o ESAPI AccessReferenceMap fornecem esta capacidade. Entenda todas as áreas em que as entradas não confiáveis podem entrar em seu software: parâmetros ou argumentos, cookies, qualquer coisa lida a partir da rede, variáveis de ambiente, pesquisas DNS reversíveis, resultados de consultas, cabeçalhos de solicitação, componentes de URL, e-mail, arquivos, bancos de dados e quaisquer sistemas externos que fornecem dados para a aplicação. Lembre-se de que essas entradas podem ser obtidas indiretamente através de chamadas de API. Muitos problemas de redirecionamento aberto ocorrem porque o programador assumiu que certas entradas não poderiam ser modificadas, tais como cookies e campos de formulário ocultos.",
    "alert": "Redirecionamento externo",
    "alertRef": "20019-3"
  },
  {
    "description": "Os redirecionadores de URL representam uma funcionalidade comum empregada por sites para encaminhar um pedido de entrada para um recurso alternativo. Isso pode ser feito por uma variedade de razões e muitas vezes é feito para permitir que os recursos sejam movidos dentro da estrutura do diretório e para evitar quebra de funcionalidade para os usuários que solicitam o recurso em seu local anterior. Os redirecionadores de URL também podem ser usados para implementar balanceamento de carga, alavancando URLs abreviadas ou gravando links de saída. É esta última implementação que é frequentemente usada em ataques de phishing como descrito no exemplo abaixo. Os redirecionadores de URL não representam necessariamente uma vulnerabilidade de segurança direta, mas podem ser abusados por atacantes tentando as vítimas de engenheiro social em acreditar que eles estão navegando para um site diferente do destino verdadeiro.",
    "solution": "Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Use uma lista de permissões de URLs ou domínios aprovados para ser usado para redirecionamento. Use uma página de aviso intermediário que fornece ao usuário um aviso claro de que eles estão deixando seu site. Implemente um longo prazo antes do redirecionamento ocorrer, ou forçar o usuário a clicar no link. Tenha cuidado para evitar problemas do XSS ao gerar a página de aviso. Quando o conjunto de objetos aceitáveis, como nomes de arquivos ou URLs, é limitado ou conhecido, criar um mapeamento de um conjunto de valores de entrada fixos (como IDs numéricos) para os nomes de arquivos ou URLs reais, e rejeitar todas as outras entradas. Por exemplo, ID 1 poderia mapear para /login.asp e ID 2 poderia mapear para http://www.example.com Características como o ESAPI AccessReferenceMap fornecem esta capacidade. Entenda todas as áreas em que as entradas não confiáveis podem entrar em seu software: parâmetros ou argumentos, cookies, qualquer coisa lida a partir da rede, variáveis de ambiente, pesquisas DNS reversíveis, resultados de consultas, cabeçalhos de solicitação, componentes de URL, e-mail, arquivos, bancos de dados e quaisquer sistemas externos que fornecem dados para a aplicação. Lembre-se de que essas entradas podem ser obtidas indiretamente através de chamadas de API. Muitos problemas de redirecionamento aberto ocorrem porque o programador assumiu que certas entradas não poderiam ser modificadas, tais como cookies e campos de formulário ocultos.",
    "alert": "Redirecionamento externo",
    "alertRef": "20019-4"
  },
  {
    "description": "Os erros de transbordamento do buffer são caracterizados pela substituição de espaços de memória do processo web de fundo, que nunca deveriam ter sido modificados intencionalmente ou não. Os valores de substituição do IP (Instruction Pointer,) BP (Base Pointer) e outros registros causam exceções, falhas de segmentação e outros erros de processo a ocorrer. Normalmente esses erros terminam a execução do aplicativo de uma forma inesperada.",
    "solution": "Reescrever o programa de fundo usando a verificação adequada do comprimento de retorno. Isso exigirá um recumpile do executável de fundo.",
    "alert": "Fluxo de buffer",
    "alertRef": "30000"
  },
  {
    "description": "Um erro Format String ocorre quando os dados enviados de uma cadeia de entrada são avaliados como um comando pelo aplicativo.",
    "solution": "Reescrever o programa de fundo usando a exclusão adequada de strings de caracteres ruins. Isso exigirá um recumpile do executável de fundo.",
    "alert": "Erro de formatação",
    "alertRef": "30002"
  },
  {
    "description": "Existe uma condição de fluxo inteiro quando um inteiro usado em um programa compilado se estende além dos limites de intervalo e não foi devidamente verificado a partir do fluxo de entrada.",
    "solution": "A fim de evitar transbordagens e dividir por 0 (zero) erros no aplicativo, reescrever o programa de backend, verificar se os valores dos inteiros que estão sendo processados estão dentro do intervalo permitido da aplicação. Isso exigirá uma recompilação do executável backend.",
    "alert": "Erro de Integer Overflow",
    "alertRef": "30003"
  },
  {
    "description": "O cookie pode ser ajustado através da injeção CRLF. Também pode ser possível definir cabeçalhos de resposta HTTP arbitrários. Além disso, ao elaborar cuidadosamente a resposta injetada usando script cross-site, a vulnerabilidade de envenenamento de cache também pode existir.",
    "solution": "Digite o parâmetro submetido cuidadosamente. Não permita que CRLF seja injetado filtrando CRLF.",
    "alert": "CRIMAIS Injeção",
    "alertRef": "40003"
  },
  {
    "description": "A manipulação do parâmetro fez com que uma página de erro ou o traço da pilha Java fosse exibido. Isso indicou a falta de tratamento de exceção e áreas potenciais para maior exploração.",
    "solution": "Identificar a causa do erro e corrigi-lo. Não confie na entrada lateral do cliente e aplique uma verificação apertada no lado do servidor. Além disso, pegue a exceção corretamente. Use uma página de erro 500 genérica para erro de servidor interno.",
    "alert": "Tamperagem do parâmetro",
    "alertRef": "40008"
  },
  {
    "description": "Alguns parâmetros podem fazer com que os comandos Server Side Inclui sejam executados. Isso pode permitir que a conexão de banco de dados ou o código arbitrário seja executado.",
    "solution": "Não confie na entrada lateral do cliente e aplique uma verificação apertada no lado do servidor. Desativar o lado do servidor inclui.",
    "alert": "Lado do servidor Incluir",
    "alertRef": "40009"
  },
  {
    "description": "Cross-site Scripting (XSS) é uma técnica de ataque que envolve ecoar código aplicado ao atacante em uma instância do navegador do usuário. Uma instância do navegador pode ser um cliente padrão do navegador da web, ou um objeto do navegador incorporado em um produto de software, como o navegador dentro do WinAmp, um leitor de RSS ou um cliente de e-mail. O código em si é geralmente escrito em HTML/JavaScript, mas também pode se estender ao VBScript, ActiveX, Java, Flash ou qualquer outra tecnologia suportada pelo navegador. Quando um atacante recebe o navegador de um usuário para executar seu código, o código será executado dentro do contexto de segurança (ou zona) do site de hospedagem. Com este nível de privilégio, o código tem a capacidade de ler, modificar e transmitir quaisquer dados confidenciais acessíveis pelo navegador. Um usuário do Cross-site Scripted poderia ter sua conta sequestrada (roubo de cookie,) seu navegador redirecionado para outro local, ou possivelmente mostrado conteúdo fraudulento entregue pelo site que eles estão visitando. Os ataques de scripting do local cruzado comprometem essencialmente a relação de confiança entre um usuário e o site. As aplicações que utilizam instâncias de objetos de navegador que carregam conteúdo do sistema de arquivos podem executar o código sob a zona de máquinas local, permitindo o compromisso do sistema.",
    "solution": "Fase: Arquitetura e Design Use uma biblioteca ou estrutura vetada que não permita que essa fraqueza ocorra ou forneça construções que tornem essa fraqueza mais fácil de evitar. Exemplos de bibliotecas e frameworks que facilitam a geração de saída codificada corretamente incluem a biblioteca Anti-XSS da Microsoft, o módulo ESAPI Encoding OWASP e Apache Wicket. Fases: Implementação; Arquitetura e Design Entenda o contexto em que seus dados serão usados e a codificação que será esperada. Isso é especialmente importante ao transmitir dados entre diferentes componentes, ou ao gerar saídas que podem conter várias codificações ao mesmo tempo, como páginas web ou mensagens de correio multi-parte. Estude todos os protocolos de comunicação esperados e representações de dados para determinar as estratégias de codificação necessárias. Para quaisquer dados que sejam de saída para outra página web, especialmente quaisquer dados que foram recebidos de entradas externas, use a codificação apropriada em todos os caracteres não-alfaméricos. Consulte o XSS Prevenção Cheat Sheet para obter mais detalhes sobre os tipos de codificação e escape que são necessários. Fase: Arquitetura e Design Para quaisquer verificações de segurança realizadas no lado do cliente, certifique-se de que essas verificações são duplicadas no lado do servidor, a fim de evitar CWE-602. Os atacantes podem contornar as verificações do lado do cliente modificando os valores após as verificações terem sido realizadas, ou alterando o cliente para remover completamente as verificações do lado do cliente. Em seguida, esses valores modificados seriam submetidos ao servidor. Se disponível, use mecanismos estruturados que impõem automaticamente a separação entre dados e códigos. Esses mecanismos podem ser capazes de fornecer a citação, codificação e validação relevantes automaticamente, em vez de confiar no desenvolvedor para fornecer essa capacidade em cada ponto onde a saída é gerada. Fase: Implementação Para cada página web que é gerada, use e especifique uma codificação de caracteres como ISO-8859-1 ou UTF-8. Quando uma codificação não é especificada, o navegador da web pode escolher uma codificação diferente, adivinhando qual codificação está realmente sendo usado pela página da web. Isso pode fazer com que o navegador da web trate certas sequências como especiais, abrindo o cliente para sutis ataques XSS. Veja CWE-116 para mais mitigações relacionadas à codificação/escapagem. Para ajudar a mitigar ataques XSS contra o cookie de sessão do usuário, defina o cookie de sessão para ser HttpOnly. Em navegadores que suportam o recurso HttpOnly (como versões mais recentes do Internet Explorer e Firefox), este atributo pode impedir que o cookie de sessão do usuário seja acessível a scripts maliciosos do lado do cliente que usam o documento. cookies Esta não é uma solução completa, uma vez que HttpOnly não é suportado por todos os navegadores. Mais importante, XMLHTTPRequest e outras tecnologias poderosas do navegador fornecem acesso de leitura aos cabeçalhos HTTP, incluindo o cabeçalho Set-Cookie no qual a bandeira HttpOnly está definida. Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Certifique-se de executar a validação de entrada em interfaces bem definidas dentro do aplicativo. Isso ajudará a proteger a aplicação mesmo que um componente seja reutilizado ou movido em outro lugar.",
    "alert": "Escrita de Site Cruzado (refletido)",
    "alertRef": "40012"
  },
  {
    "description": "A fixação de sessão pode ser possível. Se este problema ocorrer com um URL de login (onde o usuário se autentica para o aplicativo), então a URL pode ser dada por um atacante, juntamente com um ID de sessão fixa, para uma vítima, a fim de mais tarde assumir a identidade da vítima usando o id da sessão dada. Se o problema ocorrer com uma página não-login, o URL e o id de sessão fixa só podem ser usados por um atacante para rastrear as ações de um usuário não autenticado. Se a vulnerabilidade ocorrer em um campo de cookies ou em um campo de formulário (parâmetro POST) em vez de em um parâmetro URL (GET), então alguma outra vulnerabilidade também pode ser necessária para definir o campo de cookies no navegador da vítima, para permitir que a vulnerabilidade seja explorada.",
    "solution": "1) Impedir que o atacante ganhe um ID de sessão através da aplicação de ids de sessão estritas, e apenas alocando ids de sessão após a autenticação bem sucedida para o aplicativo. 2) O servidor deve sempre criar um novo ID de sessão após a autenticação, independentemente de uma sessão já estar no lugar. 3) Ligar a sessão id a alguma combinação de atributos do cliente identificável, como endereço IP, certificado cliente SSL. 4) As sessões, quando destruídas, devem ser destruídas no servidor, bem como no cliente. 5) Implementar um mecanismo de logout que destruirá todas as sessões anteriores para o cliente. 6) Implementar prazos de sessão absolutos. 7) Desviar de uma URL baseada em um cookie ou uma implementação de identificação de sessão baseada em formulários, uma vez que este normalmente requer vulnerabilidades adicionais, a fim de ser explorável por um atacante",
    "alert": "Fixação de sessão",
    "alertRef": "40013"
  },
  {
    "description": "Cross-site Scripting (XSS) é uma técnica de ataque que envolve ecoar código aplicado ao atacante em uma instância do navegador do usuário. Uma instância do navegador pode ser um cliente padrão do navegador da web, ou um objeto do navegador incorporado em um produto de software, como o navegador dentro do WinAmp, um leitor de RSS ou um cliente de e-mail. O código em si é geralmente escrito em HTML/JavaScript, mas também pode se estender ao VBScript, ActiveX, Java, Flash ou qualquer outra tecnologia suportada pelo navegador. Quando um atacante recebe o navegador de um usuário para executar seu código, o código será executado dentro do contexto de segurança (ou zona) do site de hospedagem. Com este nível de privilégio, o código tem a capacidade de ler, modificar e transmitir quaisquer dados confidenciais acessíveis pelo navegador. Um usuário do Cross-site Scripted poderia ter sua conta sequestrada (roubo de cookie,) seu navegador redirecionado para outro local, ou possivelmente mostrado conteúdo fraudulento entregue pelo site que eles estão visitando. Os ataques de scripting do local cruzado comprometem essencialmente a relação de confiança entre um usuário e o site. As aplicações que utilizam instâncias de objetos de navegador que carregam conteúdo do sistema de arquivos podem executar o código sob a zona de máquinas local, permitindo o compromisso do sistema.",
    "solution": "Fase: Arquitetura e Design Use uma biblioteca ou estrutura vetada que não permita que essa fraqueza ocorra ou forneça construções que tornem essa fraqueza mais fácil de evitar. Exemplos de bibliotecas e frameworks que facilitam a geração de saída codificada corretamente incluem a biblioteca Anti-XSS da Microsoft, o módulo ESAPI Encoding OWASP e Apache Wicket. Fases: Implementação; Arquitetura e Design Entenda o contexto em que seus dados serão usados e a codificação que será esperada. Isso é especialmente importante ao transmitir dados entre diferentes componentes, ou ao gerar saídas que podem conter várias codificações ao mesmo tempo, como páginas web ou mensagens de correio multi-parte. Estude todos os protocolos de comunicação esperados e representações de dados para determinar as estratégias de codificação necessárias. Para quaisquer dados que sejam de saída para outra página web, especialmente quaisquer dados que foram recebidos de entradas externas, use a codificação apropriada em todos os caracteres não-alfaméricos. Consulte o XSS Prevenção Cheat Sheet para obter mais detalhes sobre os tipos de codificação e escape que são necessários. Fase: Arquitetura e Design Para quaisquer verificações de segurança realizadas no lado do cliente, certifique-se de que essas verificações são duplicadas no lado do servidor, a fim de evitar CWE-602. Os atacantes podem contornar as verificações do lado do cliente modificando os valores após as verificações terem sido realizadas, ou alterando o cliente para remover completamente as verificações do lado do cliente. Em seguida, esses valores modificados seriam submetidos ao servidor. Se disponível, use mecanismos estruturados que impõem automaticamente a separação entre dados e códigos. Esses mecanismos podem ser capazes de fornecer a citação, codificação e validação relevantes automaticamente, em vez de confiar no desenvolvedor para fornecer essa capacidade em cada ponto onde a saída é gerada. Fase: Implementação Para cada página web que é gerada, use e especifique uma codificação de caracteres como ISO-8859-1 ou UTF-8. Quando uma codificação não é especificada, o navegador da web pode escolher uma codificação diferente, adivinhando qual codificação está realmente sendo usado pela página da web. Isso pode fazer com que o navegador da web trate certas sequências como especiais, abrindo o cliente para sutis ataques XSS. Veja CWE-116 para mais mitigações relacionadas à codificação/escapagem. Para ajudar a mitigar ataques XSS contra o cookie de sessão do usuário, defina o cookie de sessão para ser HttpOnly. Em navegadores que suportam o recurso HttpOnly (como versões mais recentes do Internet Explorer e Firefox), este atributo pode impedir que o cookie de sessão do usuário seja acessível a scripts maliciosos do lado do cliente que usam o documento. cookies Esta não é uma solução completa, uma vez que HttpOnly não é suportado por todos os navegadores. Mais importante, XMLHTTPRequest e outras tecnologias poderosas do navegador fornecem acesso de leitura aos cabeçalhos HTTP, incluindo o cabeçalho Set-Cookie no qual a bandeira HttpOnly está definida. Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Certifique-se de executar a validação de entrada em interfaces bem definidas dentro do aplicativo. Isso ajudará a proteger a aplicação mesmo que um componente seja reutilizado ou movido em outro lugar.",
    "alert": "Roteiro de Sites Cruzados (Persistente)",
    "alertRef": "40014"
  },
  {
    "description": "LDAP A injeção pode ser possível. Pode ser possível que um atacante ignore os controles de autenticação e visualize e modifique dados arbitrários no diretório LDAP.",
    "solution": "Validar e/ou escapar de todas as entradas de usuário antes de usá-las para criar uma consulta LDAP. Em particular, os seguintes caracteres (ou combinações) devem ser negados listados: & | ! < > = ~= <= * ( ) , + - ' ; / NUL character",
    "alert": "Injeção de LDAP",
    "alertRef": "40015"
  },
  {
    "description": "N/A",
    "solution": "N/A",
    "alert": "Roteiro de Sites Cruzados (Persistente) - Prime",
    "alertRef": "40016"
  },
  {
    "description": "N/A",
    "solution": "N/A",
    "alert": "Escrita de Site Cruzado (Persistente) - Aranha",
    "alertRef": "40017"
  },
  {
    "description": "A injeção SQL pode ser possível.",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o princípio de menor privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção de SQL",
    "alertRef": "40018"
  },
  {
    "description": "Injeção SQL pode ser possível",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o privilégio de menos privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção SQL - MySQL",
    "alertRef": "40019"
  },
  {
    "description": "Injeção SQL pode ser possível",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o privilégio de menos privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção SQL - Hypersonic SQL",
    "alertRef": "40020"
  },
  {
    "description": "Injeção SQL pode ser possível",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o privilégio de menos privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção SQL - Oracle",
    "alertRef": "40021"
  },
  {
    "description": "Injeção SQL pode ser possível",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o privilégio de menos privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção SQL - PostgreSQL",
    "alertRef": "40022"
  },
  {
    "description": "Pode ser possível enumerar nomes de usuário, com base em diferentes respostas HTTP quando são fornecidos nomes de usuário válidos e inválidos. Isso aumentaria consideravelmente a probabilidade de sucesso de ataques de força bruta de senha contra o sistema. Note que os falsos positivos podem, por vezes, ser minimizados, aumentando a opção \"Attack Force\" no ZAP. Por favor, verifique manualmente o campo ‘Outras informações’ para confirmar se este é realmente um problema.",
    "solution": "Não divulgue detalhes sobre se um nome de usuário é válido ou inválido. Em particular, para tentativas de login sem sucesso, não diferencie entre um usuário inválido e uma senha inválida na mensagem de erro, título da página, conteúdo da página, cabeçalhos HTTP ou lógica de redirecionamento.",
    "alert": "Nome de usuário possível Enumeração",
    "alertRef": "40023"
  },
  {
    "description": "Injeção SQL pode ser possível",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o privilégio de menos privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção SQL - SQLite",
    "alertRef": "40024"
  },
  {
    "description": "Cross-site Scripting (XSS) é uma técnica de ataque que envolve ecoar código aplicado ao atacante em uma instância do navegador do usuário. Uma instância do navegador pode ser um cliente padrão do navegador da web, ou um objeto do navegador incorporado em um produto de software, como o navegador dentro do WinAmp, um leitor de RSS ou um cliente de e-mail. O código em si é geralmente escrito em HTML/JavaScript, mas também pode se estender ao VBScript, ActiveX, Java, Flash ou qualquer outra tecnologia suportada pelo navegador. Quando um atacante recebe o navegador de um usuário para executar seu código, o código será executado dentro do contexto de segurança (ou zona) do site de hospedagem. Com este nível de privilégio, o código tem a capacidade de ler, modificar e transmitir quaisquer dados confidenciais acessíveis pelo navegador. Um usuário do Cross-site Scripted poderia ter sua conta sequestrada (roubo de cookie,) seu navegador redirecionado para outro local, ou possivelmente mostrado conteúdo fraudulento entregue pelo site que eles estão visitando. Os ataques de scripting do local cruzado comprometem essencialmente a relação de confiança entre um usuário e o site. As aplicações que utilizam instâncias de objetos de navegador que carregam conteúdo do sistema de arquivos podem executar o código sob a zona de máquinas local, permitindo o compromisso do sistema.",
    "solution": "Fase: Arquitetura e Design Use uma biblioteca ou estrutura vetada que não permita que essa fraqueza ocorra ou forneça construções que tornem essa fraqueza mais fácil de evitar. Exemplos de bibliotecas e frameworks que facilitam a geração de saída codificada corretamente incluem a biblioteca Anti-XSS da Microsoft, o módulo ESAPI Encoding OWASP e Apache Wicket. Fases: Implementação; Arquitetura e Design Entenda o contexto em que seus dados serão usados e a codificação que será esperada. Isso é especialmente importante ao transmitir dados entre diferentes componentes, ou ao gerar saídas que podem conter várias codificações ao mesmo tempo, como páginas web ou mensagens de correio multi-parte. Estude todos os protocolos de comunicação esperados e representações de dados para determinar as estratégias de codificação necessárias. Para quaisquer dados que sejam de saída para outra página web, especialmente quaisquer dados que foram recebidos de entradas externas, use a codificação apropriada em todos os caracteres não-alfaméricos. Consulte o XSS Prevenção Cheat Sheet para obter mais detalhes sobre os tipos de codificação e escape que são necessários. Fase: Arquitetura e Design Para quaisquer verificações de segurança realizadas no lado do cliente, certifique-se de que essas verificações são duplicadas no lado do servidor, a fim de evitar CWE-602. Os atacantes podem contornar as verificações do lado do cliente modificando os valores após as verificações terem sido realizadas, ou alterando o cliente para remover completamente as verificações do lado do cliente. Em seguida, esses valores modificados seriam submetidos ao servidor. Se disponível, use mecanismos estruturados que impõem automaticamente a separação entre dados e códigos. Esses mecanismos podem ser capazes de fornecer a citação, codificação e validação relevantes automaticamente, em vez de confiar no desenvolvedor para fornecer essa capacidade em cada ponto onde a saída é gerada. Fase: Implementação Para cada página web que é gerada, use e especifique uma codificação de caracteres como ISO-8859-1 ou UTF-8. Quando uma codificação não é especificada, o navegador da web pode escolher uma codificação diferente, adivinhando qual codificação está realmente sendo usado pela página da web. Isso pode fazer com que o navegador da web trate certas sequências como especiais, abrindo o cliente para sutis ataques XSS. Veja CWE-116 para mais mitigações relacionadas à codificação/escapagem. Para ajudar a mitigar ataques XSS contra o cookie de sessão do usuário, defina o cookie de sessão para ser HttpOnly. Em navegadores que suportam o recurso HttpOnly (como versões mais recentes do Internet Explorer e Firefox), este atributo pode impedir que o cookie de sessão do usuário seja acessível a scripts maliciosos do lado do cliente que usam o documento. cookies Esta não é uma solução completa, uma vez que HttpOnly não é suportado por todos os navegadores. Mais importante, XMLHTTPRequest e outras tecnologias poderosas do navegador fornecem acesso de leitura aos cabeçalhos HTTP, incluindo o cabeçalho Set-Cookie no qual a bandeira HttpOnly está definida. Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Certifique-se de executar a validação de entrada em interfaces bem definidas dentro do aplicativo. Isso ajudará a proteger a aplicação mesmo que um componente seja reutilizado ou movido em outro lugar.",
    "alert": "Roteiro de Sites Cruzados (baseado em DOM)",
    "alertRef": "40026"
  },
  {
    "description": "Injeção SQL pode ser possível",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o privilégio de menos privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção de SQL - MsSQL",
    "alertRef": "40027"
  },
  {
    "description": "Os módulos de registro de erro e manipuladores (ELMAH [elmah.axd)] O módulo HTTP foi encontrado disponível. Este módulo pode vazar uma quantidade significativa de informações valiosas.",
    "solution": "Considere se o ELMAH é realmente necessário na produção, se não é então desabilitá-lo. Se for então garantir o acesso a ele requer autenticação e autorização. Ver também: https://elmah.github.io/a/securing-error-log-pages",
    "alert": "InformaÃ§Ã£o ELMAH",
    "alertRef": "40028"
  },
  {
    "description": "O ASP.NET Trace Viewer (trace.axd) estava disponível. Este componente pode vazar uma quantidade significativa de informações valiosas.",
    "solution": "Considere se Trace ou não Viewer é realmente necessário na produção, se não é, em seguida, desabilitá-lo. Se for então garantir o acesso a ele requer autenticação e autorização.",
    "alert": "InformaÃ§Ã£o Trace.axd",
    "alertRef": "40029"
  },
  {
    "description": "Cross-site Scripting (XSS) é uma técnica de ataque que envolve ecoar código aplicado ao atacante em uma instância do navegador do usuário. Uma instância do navegador pode ser um cliente padrão do navegador da web, ou um objeto do navegador incorporado em um produto de software, como o navegador dentro do WinAmp, um leitor de RSS ou um cliente de e-mail. O código em si é geralmente escrito em HTML/JavaScript, mas também pode se estender ao VBScript, ActiveX, Java, Flash ou qualquer outra tecnologia suportada pelo navegador. Quando um atacante recebe o navegador de um usuário para executar seu código, o código será executado dentro do contexto de segurança (ou zona) do site de hospedagem. Com este nível de privilégio, o código tem a capacidade de ler, modificar e transmitir quaisquer dados confidenciais acessíveis pelo navegador. Um usuário do Cross-site Scripted poderia ter sua conta sequestrada (roubo de cookie,) seu navegador redirecionado para outro local, ou possivelmente mostrado conteúdo fraudulento entregue pelo site que eles estão visitando. Os ataques de scripting do local cruzado comprometem essencialmente a relação de confiança entre um usuário e o site. As aplicações que utilizam instâncias de objetos de navegador que carregam conteúdo do sistema de arquivos podem executar o código sob a zona de máquinas local, permitindo o compromisso do sistema.",
    "solution": "Fase: Arquitetura e Design Use uma biblioteca ou estrutura vetada que não permita que essa fraqueza ocorra ou forneça construções que tornem essa fraqueza mais fácil de evitar. Exemplos de bibliotecas e frameworks que facilitam a geração de saída codificada corretamente incluem a biblioteca Anti-XSS da Microsoft, o módulo ESAPI Encoding OWASP e Apache Wicket. Fases: Implementação; Arquitetura e Design Entenda o contexto em que seus dados serão usados e a codificação que será esperada. Isso é especialmente importante ao transmitir dados entre diferentes componentes, ou ao gerar saídas que podem conter várias codificações ao mesmo tempo, como páginas web ou mensagens de correio multi-parte. Estude todos os protocolos de comunicação esperados e representações de dados para determinar as estratégias de codificação necessárias. Para quaisquer dados que sejam de saída para outra página web, especialmente quaisquer dados que foram recebidos de entradas externas, use a codificação apropriada em todos os caracteres não-alfaméricos. Consulte o XSS Prevenção Cheat Sheet para obter mais detalhes sobre os tipos de codificação e escape que são necessários. Fase: Arquitetura e Design Para quaisquer verificações de segurança realizadas no lado do cliente, certifique-se de que essas verificações são duplicadas no lado do servidor, a fim de evitar CWE-602. Os atacantes podem contornar as verificações do lado do cliente modificando os valores após as verificações terem sido realizadas, ou alterando o cliente para remover completamente as verificações do lado do cliente. Em seguida, esses valores modificados seriam submetidos ao servidor. Se disponível, use mecanismos estruturados que impõem automaticamente a separação entre dados e códigos. Esses mecanismos podem ser capazes de fornecer a citação, codificação e validação relevantes automaticamente, em vez de confiar no desenvolvedor para fornecer essa capacidade em cada ponto onde a saída é gerada. Fase: Implementação Para cada página web que é gerada, use e especifique uma codificação de caracteres como ISO-8859-1 ou UTF-8. Quando uma codificação não é especificada, o navegador da web pode escolher uma codificação diferente, adivinhando qual codificação está realmente sendo usado pela página da web. Isso pode fazer com que o navegador da web trate certas sequências como especiais, abrindo o cliente para sutis ataques XSS. Veja CWE-116 para mais mitigações relacionadas à codificação/escapagem. Para ajudar a mitigar ataques XSS contra o cookie de sessão do usuário, defina o cookie de sessão para ser HttpOnly. Em navegadores que suportam o recurso HttpOnly (como versões mais recentes do Internet Explorer e Firefox), este atributo pode impedir que o cookie de sessão do usuário seja acessível a scripts maliciosos do lado do cliente que usam o documento. cookies Esta não é uma solução completa, uma vez que HttpOnly não é suportado por todos os navegadores. Mais importante, XMLHTTPRequest e outras tecnologias poderosas do navegador fornecem acesso de leitura aos cabeçalhos HTTP, incluindo o cabeçalho Set-Cookie no qual a bandeira HttpOnly está definida. Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Certifique-se de executar a validação de entrada em interfaces bem definidas dentro do aplicativo. Isso ajudará a proteger a aplicação mesmo que um componente seja reutilizado ou movido em outro lugar.",
    "alert": "Fora da Banda XSS",
    "alertRef": "40031"
  },
  {
    "description": "arquivos htaccess podem ser usados para alterar a configuração do software Apache Web Server para ativar/desativar funcionalidades adicionais e recursos que o software Apache Web Server tem para oferecer.",
    "solution": "Certifique-se de que o arquivo .htaccess não é acessível.",
    "alert": ".htaccess Informações",
    "alertRef": "40032"
  },
  {
    "description": "Mongo Injeção de consulta DB pode ser possível.",
    "solution": "Não confie na entrada lateral do cliente e escape todos os dados no lado do servidor. Evite usar a entrada de consulta diretamente nas cláusulas onde e grupo e atualizar todos os drivers na versão mais recente disponível.",
    "alert": "Injeção de NoSQL - MongoDB",
    "alertRef": "40033"
  },
  {
    "description": "Um ou mais arquivos .env parece ter sido localizado no servidor. Esses arquivos frequentemente expõem credenciais de infraestrutura ou contas administrativas, chaves API ou APP, ou outras informações de configuração confidenciais.",
    "solution": "Certifique-se de que o arquivo .env não é acessível.",
    "alert": ".env Informação Leak",
    "alertRef": "40034"
  },
  {
    "description": "Um arquivo sensível foi identificado como acessível ou disponível. Isso pode vazar informações administrativas, configuração ou credenciais que podem ser aproveitadas por um indivíduo malicioso para atacar ainda mais o sistema ou realizar esforços de engenharia social.",
    "solution": "Considere se o componente é realmente necessário na produção, se não é então desabilitá-lo. Se for então garantir o acesso a ele requer autenticação e autorização apropriadas, ou limitar a exposição a sistemas internos ou IPs de fonte específicos, etc.",
    "alert": "Arquivo oculto encontrado",
    "alertRef": "40035"
  },
  {
    "description": "Scanner para encontrar vulnerabilidades em implementações JWT.",
    "solution": "Consulte a referência para mais informações. A solução depende de detalhes de implementação",
    "alert": "JWT Regra de digitalização",
    "alertRef": "40036"
  },
  {
    "description": "O engano de cache da Web pode ser possível. Pode ser possível que o usuário não autorizado visualize dados confidenciais nesta página.",
    "solution": "É fortemente aconselhado a abster-se de classificar tipos de arquivo, tais como imagens ou folhas de estilo exclusivamente por sua URL e extensão de arquivo. Em vez disso, você deve ter certeza de que os arquivos são armazenados em cache com base em seu cabeçalho Content-Type.",
    "alert": "Web Cache Deception",
    "alertRef": "40039"
  },
  {
    "description": "Cross-Origin Resource Sharing (CORS) é um mecanismo baseado em cabeçalho HTTP que permite que um servidor indique qualquer outra origem (domínio, esquema ou porta) do que sua própria a partir da qual um navegador deve permitir o carregamento de recursos. Relaxa a Política Same-Origin (SOP.)",
    "solution": "Se um recurso web contém informações sensíveis, a origem deve ser especificada corretamente no cabeçalho Access-Control-Allow-Origin. Apenas sites confiáveis que precisam deste recurso devem ser especificados neste cabeçalho, com o protocolo mais seguro suportado.",
    "alert": "CORSÃO Cabeçalho",
    "alertRef": "40040-1"
  },
  {
    "description": "Esta misconfiguração CORS poderia permitir que um atacante realizasse consultas AJAX para o site vulnerável de uma página maliciosa carregada pelo agente de usuário da vítima. Para realizar consultas AJAX autenticadas, o servidor deve especificar o cabeçalho “Access-Control-Allow-Credentials: true” e o cabeçalho “Access-Control-Allow-Origin” deve ser definido como nulo ou domínio da página malicioso. Mesmo que essa misconfiguração não permita solicitações autenticadas do AJAX, conteúdo sensível não autenticado ainda pode ser acessado (por exemplo, sites intranet.) Uma página maliciosa pode pertencer a um site malicioso, mas também um site confiável com falhas (por exemplo, XSS, suporte de HTTP sem TLS permitindo injeção de código através de MITM, etc.)",
    "solution": "Se um recurso web contém informações sensíveis, a origem deve ser especificada corretamente no cabeçalho Access-Control-Allow-Origin. Apenas sites confiáveis que precisam deste recurso devem ser especificados neste cabeçalho, com o protocolo mais seguro suportado.",
    "alert": "CORSÃO Misconfiguração",
    "alertRef": "40040-2"
  },
  {
    "description": "Esta misconfiguração CORS poderia permitir que um atacante realizasse consultas AJAX para o site vulnerável de uma página maliciosa carregada pelo agente de usuário da vítima. Para realizar consultas AJAX autenticadas, o servidor deve especificar o cabeçalho “Access-Control-Allow-Credentials: true” e o cabeçalho “Access-Control-Allow-Origin” deve ser definido como nulo ou domínio da página malicioso. Mesmo que essa misconfiguração não permita solicitações autenticadas do AJAX, conteúdo sensível não autenticado ainda pode ser acessado (por exemplo, sites intranet.) Uma página maliciosa pode pertencer a um site malicioso, mas também um site confiável com falhas (por exemplo, XSS, suporte de HTTP sem TLS permitindo injeção de código através de MITM, etc.)",
    "solution": "Se um recurso web contém informações sensíveis, a origem deve ser especificada corretamente no cabeçalho Access-Control-Allow-Origin. Apenas sites confiáveis que precisam deste recurso devem ser especificados neste cabeçalho, com o protocolo mais seguro suportado.",
    "alert": "CORSÃO Misconfiguração",
    "alertRef": "40040-3"
  },
  {
    "description": "A regra de digitalização de upload de arquivos é usada para verificar as vulnerabilidades na funcionalidade de upload de arquivos de aplicativos da web.",
    "solution": "Siga as sugestões mencionadas nos seguintes links: 1. https://portswigger.net/kb/issues/00500980_file-upload-functionality 2. https://www.youtube.com/watch?v=CmF9sEyKZNo",
    "alert": "Arquivo Upload",
    "alertRef": "40041"
  },
  {
    "description": "O atuador de primavera para a saúde está habilitado e pode revelar informações sensíveis sobre esta aplicação. Primavera Os atuadores podem ser usados para fins de monitoramento reais, mas devem ser usados com cautela para não expor muita informação sobre a aplicação ou a infraestrutura que a executa.",
    "solution": "Desativar os Atuadores de Saúde e outros atuadores, ou restringi-los a usuários administrativos.",
    "alert": "InformaÃ§Ã£o sobre Spring Actuator",
    "alertRef": "40042"
  },
  {
    "description": "Apache Log4j2 =<2.14.1 JNDI recursos utilizados na configuração, mensagens de log e parâmetros não protegem contra o atacante controlado LDAP e outros endpoints relacionados com JNDI. Um atacante que pode controlar as mensagens de log ou os parâmetros da mensagem de log pode executar o código arbitrário carregado de servidores LDAP quando a substituição da pesquisa da mensagem está ativada. De log4j 2.15.0, este comportamento foi desativado por padrão.",
    "solution": "Atualize Log4j2 para a versão 2.17.1 ou mais recente. Em versões anteriores (>2.10) este comportamento pode ser mitigado pela definição de propriedade do sistema log4j2.formatMsgNoLookups para true ou removendo a classe JndiLookup do classpath (exemplo: zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class) Java 8u121 (veja https://www.oracle.com/java/technologies/javase/8u121-relnotes.html) protege contra a execução de código remoto por padrão com.sun.jndi.rmi.object.trustURLCodebase e com.sun.jndi.cosnaming.object.trustURLCodebase para false.",
    "alert": "Log4Shell (CVE-2021-44228)",
    "alertRef": "40043-1"
  },
  {
    "description": "Foi encontrado que a correção para endereço CVE-2021-44228 no Apache Log4j 2.15.0 foi incompleta em certas configurações não-default. Isso pode permitir que os atacantes criem dados de entrada maliciosos usando um padrão JNDI Lookup resultando em um vazamento de informações e execução de código remoto em alguns ambientes.",
    "solution": "Atualize Log4j2 para a versão 2.17.1 ou mais recente.",
    "alert": "Log4Shell (CVE-2021-45046)",
    "alertRef": "40043-2"
  },
  {
    "description": "Uma expansão da entidade exponencial, ou “bilhões de risos” ataque é um tipo de ataque de negação de serviço (DoS). É destinado a parsers de linguagens de marcação como XML ou YAML que permitem expansões macro.",
    "solution": "Defesas contra este tipo de ataque incluem capping a memória alocada em um parser individual se a perda do documento é aceitável, ou tratar entidades simbolicamente e expandi-los preguiçosamente apenas quando (e na medida) seu conteúdo deve ser usado.",
    "alert": "Expansão da Entidade Exponencial (Ataque de Milhões de Massas)",
    "alertRef": "40044"
  },
  {
    "description": "O aplicativo parece ser vulnerável a CVE-2022-22965 (outro, conhecido como Spring4Shell) - execução de código remoto (RCE) através de ligação de dados.",
    "solution": "Atualize o Spring Framework para as versões 5.3.18, 5.2.20 ou mais recente.",
    "alert": "Máquina de montagem automática",
    "alertRef": "40045"
  },
  {
    "description": "A resposta na URL a seguir contém um valor ViewState que não tem proteções criptográficas.",
    "solution": "VIEWSTATE seguro com um MAC específico para o seu ambiente",
    "alert": "Inseguro JSF ViewState",
    "alertRef": "90001"
  },
  {
    "description": "Serialização Java parece estar em uso. Se não validado corretamente, um atacante pode enviar um objeto especialmente trabalhado. Isso pode levar a uma perigosa “Executão de Código Remoto”. Uma sequência mágica identificando JSO foi detectada (Base64: rO0AB, Raw: 0xac, 0xed, 0x00, 0x05.)",
    "solution": "A deserialização de dados não confiáveis é inerentemente perigosa e deve ser evitada.",
    "alert": "Serialização Java Objeto",
    "alertRef": "90002"
  },
  {
    "description": "O atributo integridade está faltando em um script ou link tag servido por um servidor externo. A etiqueta de integridade impede um atacante que tenha adquirido acesso a este servidor de injetar um conteúdo malicioso.",
    "solution": "Fornecer um atributo de integridade válido para a tag.",
    "alert": "Sub Integridade de Recursos Missing de Atributo",
    "alertRef": "90003"
  },
  {
    "description": "O cabeçalho Cross-Origin-Resource-Policy é um cabeçalho opt-in projetado para combater ataques de canal lateral como Spectre. Os recursos devem ser especificamente definidos como compartilháveis entre diferentes origens.",
    "solution": "Certifique-se de que o aplicativo / servidor web define o cabeçalho Cross-Origin-Resource-Policy apropriadamente, e que ele define o cabeçalho Cross-Origin-Resource-Policy para o mesmo-origem para todas as páginas da web. o mesmo local é considerado menos seguro e deve ser evitado. Se os recursos devem ser compartilhados, defina o cabeçalho para cross-origin. Se possível, certifique-se de que o usuário final use um navegador web compatível com padrões e moderno que suporta o cabeçalho Cross-Origin-Resource-Policy (https://caniuse.com/mdn-http_headers_cross-origin-resource-policy)",
    "alert": "Isolamento insuficiente do local contra a vulnerabilidade do espectro",
    "alertRef": "90004-1"
  },
  {
    "description": "Cross-Origin-Embedder-Policy cabeçalho é um cabeçalho de resposta que impede um documento de carregar quaisquer recursos de orientação cruzada que não concedem explicitamente a permissão do documento (usando CORP ou CORS.)",
    "solution": "Certifique-se de que o aplicativo / servidor web define o cabeçalho Cross-Origin-Embedder-Policy apropriadamente, e que ele define o cabeçalho Cross-Origin-Embedder-Policy para exigir-corp para documentos. Se possível, certifique-se de que o usuário final use um navegador web compatível com padrões e moderno que suporta o cabeçalho Cross-Origin-Embedder-Policy (https://caniuse.com/mdn-http_headers_cross-origin-embedder-policy)",
    "alert": "Isolamento insuficiente do local contra a vulnerabilidade do espectro",
    "alertRef": "90004-2"
  },
  {
    "description": "O cabeçalho Cross-Origin-Opener-Policy é um cabeçalho de resposta que permite que um site controle se outros documentos incluídos compartilhar o mesmo contexto de navegação. Partilhar o mesmo contexto de navegação com documentos não confiáveis pode levar a vazamento de dados.",
    "solution": "Certifique-se de que o aplicativo / servidor web define o cabeçalho Cross-Origin-Opener-Policy apropriadamente, e que ele define o cabeçalho Cross-Origin-Opener-Policy para o mesmo-origem para documentos. o mesmo-origem-allow-popups é considerado como menos seguro e deve ser evitado. Se possível, assegure-se de que o usuário final use um navegador web compatível com padrões e moderno que suporta o cabeçalho Cross-Origin-Opener-Policy (https://caniuse.com/mdn-http_headers_cross-origin-opener-policy)",
    "alert": "Isolamento insuficiente do local contra a vulnerabilidade do espectro",
    "alertRef": "90004-3"
  },
  {
    "description": "Esta verificação identifica respostas onde o cabeçalho HTTP Content-Type declara um charset diferente do charset definido pelo corpo do HTML ou XML. Quando há uma falha de charset entre o cabeçalho HTTP e o corpo de conteúdo Os navegadores da Web podem ser forçados a um modo indesejável de farejar conteúdo para determinar o conjunto de caracteres correto do conteúdo.",
    "solution": "Forçar UTF-8 para todo o conteúdo de texto em ambos os cabeçalhos HTTP e meta tags em HTML ou codificando declarações em XML.",
    "alert": "Mismatch de Carset",
    "alertRef": "90011"
  },
  {
    "description": "Injeção usando transformações XSL pode ser possível, e pode permitir que um atacante para ler informações do sistema, ler e escrever arquivos, ou executar código arbitrário.",
    "solution": "Sanitize e analise todas as entradas de usuários provenientes de qualquer lado do cliente.",
    "alert": "XSLT Injeção",
    "alertRef": "90017"
  },
  {
    "description": "Uma injeção SQL pode ser possível usando a carga útil anexada",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite todos os dados no lado do servidor. Se o aplicativo usa JDBC, use PreparadStatement ou CallableStatement, com parâmetros passados por '?' Se o aplicativo usa ASP, use Objetos de Comando ADO com verificação de tipo forte e consultas parametrizadas. Se os Procedimentos Armazenados do banco de dados puderem ser usados, use-os. Não concatenar strings em consultas no procedimento armazenado, ou usar exec, 'exec imediato,' ou funcionalidade equivalente! Não crie consultas SQL dinâmicas usando concatenação de string simples. Fuja de todos os dados recebidos do cliente. Aplique uma \"lista baixa\" de caracteres permitidos, ou uma \"lista de negação\" de caracteres desalvados na entrada do usuário. Aplicar o privilégio de menos privilégio usando o usuário de banco de dados menos privilegiado possível. Em particular, evitar usar os usuários de banco de dados sa ou db-proprietário. Isso não elimina a injeção SQL, mas minimiza seu impacto. Conceda o acesso mínimo à base de dados necessário para a aplicação.",
    "alert": "Injeção SQL avançada",
    "alertRef": "90018"
  },
  {
    "description": "Uma injeção de código pode ser possível, incluindo o código personalizado que será avaliado pelo mecanismo de scripting",
    "solution": "Não confie na entrada lateral do cliente, mesmo que haja validação do lado do cliente no lugar. Em geral, digite verificar todos os dados no lado do servidor e escapar de todos os dados recebidos do cliente. Evite o uso do eval)( funções combinadas com dados de entrada do usuário.",
    "alert": "Injeção de código lateral do servidor",
    "alertRef": "90019"
  },
  {
    "description": "Técnica de ataque usada para execução não autorizada de comandos do sistema operacional. Este ataque é possível quando uma aplicação aceita entradas não confiáveis para construir comandos do sistema operacional de forma insegura envolvendo a higienização de dados impróprias e/ou chamada inadequada de programas externos.",
    "solution": "Se possível, use chamadas de biblioteca em vez de processos externos para recriar a funcionalidade desejada. Execute seu código em um ambiente de jail ou similar sandbox que impõe limites rigorosos entre o processo e o sistema operacional. Isso pode efetivamente restringir quais arquivos podem ser acessados em um determinado diretório ou quais comandos podem ser executados pelo seu software. Exemplos de nível de sistema operacional incluem a cadeia de chroot Unix, AppArmor e SELinux. Em geral, o código gerenciado pode fornecer alguma proteção. Por exemplo, java.io.FilePermission no Java Security O gerente permite especificar restrições nas operações de arquivos. Isso pode não ser uma solução viável, e limita apenas o impacto ao sistema operacional; o resto da sua aplicação ainda pode estar sujeito a compromisso. Para quaisquer dados que serão usados para gerar um comando a ser executado, mantenha o máximo desses dados fora do controle externo possível. Por exemplo, em aplicações web, isso pode exigir armazenar o comando localmente no estado da sessão em vez de enviá-lo para o cliente em um campo de formulário oculto. Use uma biblioteca ou estrutura vetada que não permita que essa fraqueza ocorra ou forneça construções que tornem essa fraqueza mais fácil de evitar. Por exemplo, considere usar o controle ESAPI Encoding ou uma ferramenta, biblioteca ou framework similar. Estes irão ajudar o programador codificar saídas de uma forma menos propensa ao erro. Se você precisar usar strings ou comandos de consulta gerados dinamicamente, apesar do risco, cite corretamente argumentos e escape de quaisquer caracteres especiais dentro desses argumentos. A abordagem mais conservadora é escapar ou filtrar todos os caracteres que não passam uma lista de permissão extremamente rigorosa (como tudo que não é espaço alfanumérico ou branco). Se alguns caracteres especiais ainda são necessários, como espaço branco, envolva cada argumento em citações após a etapa de fuga/filtroagem. Tenha cuidado com a injecção de argumentos. Se o programa a ser executado permite que os argumentos sejam especificados dentro de um arquivo de entrada ou de entrada padrão, em seguida, considere usar esse modo para passar argumentos em vez da linha de comando. Se disponível, use mecanismos estruturados que impõem automaticamente a separação entre dados e códigos. Esses mecanismos podem ser capazes de fornecer a citação, codificação e validação relevantes automaticamente, em vez de confiar no desenvolvedor para fornecer essa capacidade em cada ponto onde a saída é gerada. Alguns idiomas oferecem múltiplas funções que podem ser usadas para invocar comandos. Quando possível, identifique qualquer função que invoca um shell de comando usando uma única string e substitua-a por uma função que requer argumentos individuais. Essas funções normalmente executam citações e filtragem apropriadas de argumentos. Por exemplo, em C, a função system)( aceita uma string que contém todo o comando a ser executado, enquanto execl(,) execve(,) e outros exigem uma matriz de strings, uma para cada argumento. No Windows, CreateProcess)( só aceita um comando de cada vez. Em Perl, se o sistema)( é fornecido com uma série de argumentos, então ele irá citar cada um dos argumentos. Assumir que todas as entradas são maliciosas. Use uma estratégia de validação de entrada \"aceito conhecido bom\", ou seja, use uma lista de entradas aceitáveis que estejam estritamente em conformidade com as especificações. Rejeite qualquer entrada que não esteja estritamente em conformidade com as especificações, ou transformá-la em algo que faça. Não confie exclusivamente em procurar insumos maliciosos ou malformados (ou seja, não confie em uma lista de negação.) No entanto, as listas de negação podem ser úteis para detectar possíveis ataques ou determinar quais entradas são tão malformadas que eles devem ser rejeitadas completamente. Ao executar a validação de entrada, considere todas as propriedades potencialmente relevantes, incluindo comprimento, tipo de entrada, a gama completa de valores aceitáveis, entradas ausentes ou extras, sintaxe, consistência em campos relacionados e conformidade com as regras de negócios. Como um exemplo de lógica de regra de negócios, o barco pode ser sintacticamente válido porque contém apenas caracteres alfanuméricos, mas não é válido se você está esperando cores como vermelho ou azul. Ao construir strings de comando do sistema operacional, use listas de permissões rigorosas que limitem o conjunto de caracteres com base no valor esperado do parâmetro na solicitação. Isso limitará indiretamente o escopo de um ataque, mas esta técnica é menos importante do que a codificação de saída adequada e escapar. Note que a codificação de saída adequada, escape e citação é a solução mais eficaz para prevenir a injeção de comando do OS, embora a validação de entrada possa fornecer alguma defesa em profundidade. Isso porque efetivamente limita o que aparecerá na saída. A validação de entrada nem sempre impedirá a injeção de comando do OS, especialmente se você for obrigado a suportar campos de texto de forma livre que possam conter caracteres arbitrários. Por exemplo, ao invocar um programa de correio, você pode precisar permitir que o campo de assunto contenha entradas de outra forma perigosas como caracteres ';' e '>', que precisaria ser escapada ou tratada de outra forma. Neste caso, descascar o caractere pode reduzir o risco de injecção de comando do OS, mas produziria comportamento incorreto porque o campo de assunto não seria registrado como o usuário pretendia. Isso pode parecer um inconveniente menor, mas pode ser mais importante quando o programa depende de linhas de assunto bem estruturadas, a fim de passar mensagens para outros componentes. Mesmo se você cometer um erro em sua validação (como esquecer um de 100 campos de entrada), a codificação apropriada ainda é susceptível de protegê-lo de ataques baseados em injeção. Enquanto não for feito isoladamente, a validação de entrada ainda é uma técnica útil, uma vez que pode reduzir significativamente sua superfície de ataque, permitir que você detecte alguns ataques e fornecer outros benefícios de segurança que a codificação adequada não aborda.",
    "alert": "Injeção de comando remoto",
    "alertRef": "90020"
  },
  {
    "description": "XPath Injection é uma técnica de ataque usada para explorar aplicações que constroem consultas XPath (XML Path Language) de entrada aplicada ao usuário para consultar ou navegar documentos XML. Ele pode ser usado diretamente por um aplicativo para consultar um documento XML, como parte de uma operação maior, como aplicar uma transformação XSLT a um documento XML, ou aplicar um XQuery a um documento XML. A sintaxe de XPath tem alguma semelhança com uma consulta SQL, e de fato, é possível formar consultas semelhantes a SQL em um documento XML usando XPath.",
    "solution": "Use consultas de XPath parametrizadas (por exemplo, usando XQuery.) Isso ajudará a garantir a separação entre o plano de dados e o plano de controle. Validar corretamente a entrada do usuário. Rejeite dados quando apropriado, filtrar quando apropriado e escapar quando apropriado. Certifique-se de que a entrada que será usada em consultas XPath é segura nesse contexto.",
    "alert": "Injeção de XPath",
    "alertRef": "90021"
  },
  {
    "description": "Esta página contém uma mensagem de erro / aviso que pode divulgar informações confidenciais como a localização do arquivo que produziu a exceção não manuseada. Essas informações podem ser usadas para lançar mais ataques contra a aplicação web. O alerta pode ser um falso positivo se a mensagem de erro for encontrada dentro de uma página de documentação.",
    "solution": "Revise o código fonte desta página. Implementar páginas de erro personalizadas. Considere a implementação de um mecanismo para fornecer uma referência de erro / identificador exclusivo para o cliente (browser) ao registrar os detalhes no lado do servidor e não expô-los ao usuário.",
    "alert": "Erro de Aplicação",
    "alertRef": "90022"
  },
  {
    "description": "Esta técnica aproveita uma característica de XML para construir documentos dinamicamente no momento do processamento. Uma mensagem XML pode fornecer dados explicitamente ou apontando para uma URI onde os dados existem. Na técnica de ataque, as entidades externas podem substituir o valor da entidade por dados maliciosos, referências alternativas ou podem comprometer a segurança dos dados a que o aplicativo servidor / XML tem acesso. Os atacantes também podem usar Entidades Externas para ter o servidor de serviços web baixar código malicioso ou conteúdo para o servidor para uso em secundário ou seguir ataques.",
    "solution": "TBA",
    "alert": "XML Ataque de Entidade Externa",
    "alertRef": "90023"
  },
  {
    "description": "Ao manipular o estofamento em uma cadeia criptografada, um atacante é capaz de gerar uma mensagem de erro que indica uma provável vulnerabilidade de “oráculo de pagamento”. Tal vulnerabilidade pode afetar qualquer aplicativo ou framework que use criptografia incorretamente, como algumas versões do ASP.net, Java Server Faces e Mono. Um atacante pode explorar este problema para descriptografar dados e recuperar chaves de criptografia, potencialmente visualização e modificação de dados confidenciais. Esta regra deve detectar a vulnerabilidade do oráculo de remo MS10-070 no ASP. net se CustomErrors estão habilitados para isso.",
    "solution": "Atualize o software do servidor afetado ou modifique os scripts para validar corretamente os dados criptografados antes de tentar descriptografia.",
    "alert": "Genéricos Padding Oracle",
    "alertRef": "90024"
  },
  {
    "description": "O software constrói toda ou parte de uma declaração de linguagem de expressão (EL) em uma página de servidor Java (JSP) usando entrada de influência externa de um componente a montante, mas não neutraliza ou neutraliza incorretamente elementos especiais que poderiam modificar a declaração EL pretendida antes de ser executada. Em certas versões da Primavera 3.0.5 e anteriores, houve uma vulnerabilidade (CVE-2011-2730) na qual as tags Expression Language seriam avaliadas duas vezes, o que efetivamente expôs qualquer aplicação à injeção EL. No entanto, mesmo para versões posteriores, essa fraqueza ainda é possível dependendo da configuração.",
    "solution": "Execute a validação de dados melhor prática contra entrada não confiável e para garantir que a codificação de saída é aplicada quando os dados chegam na camada EL, de modo que nenhum metacaracter é encontrado pelo interpretador dentro do conteúdo do usuário antes da avaliação. Os padrões mais óbvios para detectar incluem ${ e #{, mas pode ser possível codificar ou fragmentar esses dados.",
    "alert": "Injeção de linguagem de expressão",
    "alertRef": "90025"
  },
  {
    "description": "Uma operação SOAP não intencional foi executada pelo servidor.",
    "solution": "Se não for necessário, o atributo SOAPAction deve ser desativado. Se necessário, a operação dentro da SOAPAction e do corpo SOAP deve ser sempre comparada antes de executar qualquer operação. Qualquer incompatibilidade deve ser considerada como um ataque.",
    "alert": "Ação SOAP Spoofing",
    "alertRef": "90026"
  },
  {
    "description": "A metodologia mais comum para os atacantes é a primeira pegada da presença web do alvo e enumerar o máximo de informação possível. Com esta informação, o atacante pode desenvolver um cenário de ataque preciso, que irá efetivamente explorar uma vulnerabilidade no tipo de software / versão sendo utilizada pelo host de destino.",
    "solution": "TBA",
    "alert": "Inseguro HTTP Método",
    "alertRef": "90028"
  },
  {
    "description": "Alguns códigos injetados XML foram interpretados pelo servidor.",
    "solution": "Use uma descrição detalhada de atributos SOAP no arquivo WSDL.",
    "alert": "Injeção de SOAP XML",
    "alertRef": "90029"
  },
  {
    "description": "Um arquivo WSDL foi detectado.",
    "solution": "Faça seus arquivos WSDL visíveis apenas para questões técnicas (ex: finalidades de teste.)",
    "alert": "Detecção de arquivos WSDL",
    "alertRef": "90030"
  },
  {
    "description": "Os cookies podem ser escopos por domínio ou caminho. Esta verificação está apenas preocupada com o escopo de domínio. O escopo de domínio aplicado a um cookie determina quais domínios podem acessá-lo. Por exemplo, um cookie pode ser escopo estritamente a um subdomínio, por exemplo, www.nottrusted.com, ou frouxamente escopo a um domínio pai, por exemplo, nottrusted.com. Neste último caso, qualquer subdomínio de nottrusted.com pode acessar o cookie. Cookies frouxamente escopo são comuns em mega-aplicações como google.com e live.com Os cookies definidos a partir de um subdomínio como app.foo.bar são transmitidos apenas para esse domínio pelo navegador. No entanto, os cookies escopo a um domínio pai-nível podem ser transmitidos para o pai, ou qualquer subdomínio do pai.",
    "solution": "Sempre escopo cookies para um FQDN (Nome de domínio totalmente qualificado.)",
    "alert": "Cookie Escocês",
    "alertRef": "90033"
  },
  {
    "description": "Os metadados da nuvem Ataque tenta abusar de um servidor NGINX mal configurado para acessar os metadados de instância mantidos por provedores de serviços em nuvem, como AWS, GCP e Azure. Todos esses provedores fornecem metadados por meio de um endereço IP instável interno ‘169.254.169.254’ - isso pode ser exposto por servidores NGINX incorretamente configurados e acessados usando este endereço IP no campo cabeçalho do host.",
    "solution": "Não confie em nenhum dado de usuário nas configurações do NGINX. Neste caso, é provavelmente o uso da variável $host que é definida a partir do cabeçalho Host e pode ser controlado por um atacante.",
    "alert": "Metadados de nuvem Potencialmente exposto",
    "alertRef": "90034"
  },
  {
    "description": "Quando a entrada do usuário é inserida no modelo em vez de ser usada como argumento na renderização é avaliada pelo motor de modelo. Dependendo do motor de modelo pode levar à execução de código remoto.",
    "solution": "Em vez de inserir a entrada do usuário no modelo, use-a como argumento de renderização.",
    "alert": "Injeção do modelo lateral do servidor",
    "alertRef": "90035"
  },
  {
    "description": "Quando a entrada do usuário é inserida no modelo em vez de ser usada como argumento na renderização é avaliada pelo motor de modelo. Dependendo do motor de modelo pode levar à execução de código remoto.",
    "solution": "Em vez de inserir a entrada do usuário no modelo, use-a como argumento de renderização.",
    "alert": "Injeção do modelo lateral do servidor (Blind)",
    "alertRef": "90036"
  },
  {
    "description": "Esta carga contém uma mensagem de erro / aviso que pode divulgar informações confidenciais como a localização do arquivo que produziu a exceção desativada. Essas informações podem ser usadas para lançar mais ataques contra a aplicação web.",
    "solution": "Revise as cargas de erro que são canalizadas diretamente para WebSockets. Lidar com as exceções relacionadas. Considere a implementação de um mecanismo para fornecer uma referência de erro / identificador exclusivo para o cliente (browser) ao registrar os detalhes no lado do servidor e não expô-los ao usuário.",
    "alert": "Erro de Aplicação Disclosure via WebSockets",
    "alertRef": "110."
  },
  {
    "description": "Uma string codificada Base64 foi encontrada na mensagem de entrada do websocket. Os dados codificados pela Base64 podem conter informações confidenciais, como nomes de usuário, senhas ou cookies que devem ser inspecionados. Evidência decodificada: exemplo.",
    "solution": "A codificação Base64 não deve ser usada para armazenar ou enviar informações confidenciais.",
    "alert": "Divulgação Base64 na mensagem WebSocket",
    "alertRef": "110002"
  },
  {
    "description": "A resposta parecia conter mensagens de erro comuns retornadas por plataformas como o ASP. NET e Web-servers como IIS e Apache. Você pode configurar a lista de mensagens de depuração comuns.",
    "solution": "Desativar mensagens de depuração antes de empurrar para a produção.",
    "alert": "Divulgação da Informação - Mensagens de erro de depuração via WebSocket",
    "alertRef": "110003"
  },
  {
    "description": "Um endereço de e-mail foi encontrado em uma Mensagem WebSocket.",
    "solution": "Remova e-mails que não são públicos.",
    "alert": "Endereço de e-mail encontrado na mensagem WebSocket",
    "alertRef": "110004"
  },
  {
    "description": "Um IP privado (como 10.x.x.x.x, 172.x.x.x, 192.168.x.x) ou um hostname privado do Amazon EC2 (por exemplo, ip-10-0-56-78) foi encontrado na mensagem WebSocket recebida. Essas informações podem ser úteis para novos ataques direcionados a sistemas internos.",
    "solution": "Remova o endereço IP privado das mensagens WebSocket.",
    "alert": "Divulgação IP privada via WebSocket",
    "alertRef": "110006"
  },
  {
    "description": "Um exemplo hash de {Example / contexto: Exemplo} foi encontrado na mensagem WebSocket recebida. Isso pode indicar que o aplicativo está sujeito a uma vulnerabilidade Insecure Direct Object Reference (IDOR). Os testes manuais serão necessários para ver se essa descoberta pode ser abusada.",
    "solution": "Use por usuário ou sessão referências de objetos indiretas (crie um mapeamento temporário no momento do uso.) Ou, certifique-se de que cada uso de uma referência de objeto direto esteja vinculado a uma verificação de autorização para garantir que o usuário esteja autorizado para o objeto solicitado.",
    "alert": "Nome de usuário Hash encontrado na mensagem WebSocket",
    "alertRef": "110007"
  },
  {
    "description": "A resposta parece conter comentários suspeitos que podem ajudar um atacante.",
    "solution": "Remova todos os comentários que retornam informações que podem ajudar um atacante e corrigir quaisquer problemas subjacentes que eles se referem.",
    "alert": "Divulgação de informações - Comentários suspeitos em XML via WebSocket",
    "alertRef": "110008"
  }
]
